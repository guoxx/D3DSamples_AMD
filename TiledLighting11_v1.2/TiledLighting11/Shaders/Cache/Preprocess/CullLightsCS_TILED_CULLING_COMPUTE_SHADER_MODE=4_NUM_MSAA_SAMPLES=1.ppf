#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\TilingForward.hlsl"


#line 53


#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\CommonHeader.h"


#line 56
static const float4 kRadarColors [ 14 ] = 
{ 
    { 0 , 0.9255 , 0.9255 , 1 } , 
    { 0 , 0.62745 , 0.9647 , 1 } , 
    { 0 , 0 , 0.9647 , 1 } , 
    { 0 , 1 , 0 , 1 } , 
    { 0 , 0.7843 , 0 , 1 } , 
    { 0 , 0.5647 , 0 , 1 } , 
    { 1 , 1 , 0 , 1 } , 
    { 0.90588 , 0.75294 , 0 , 1 } , 
    { 1 , 0.5647 , 0 , 1 } , 
    { 1 , 0 , 0 , 1 } , 
    { 0.8392 , 0 , 0 , 1 } , 
    { 0.75294 , 0 , 0 , 1 } , 
    { 1 , 0 , 1 , 1 } , 
    { 0.6 , 0.3333 , 0.7882 , 1 } , 
} ; 

#line 78




#line 86



#line 92
cbuffer cbPerObject : register ( b0 ) 
{ 
    matrix g_mWorld : packoffset ( c0 ) ; 
} 

cbuffer cbPerCamera : register ( b1 ) 
{ 
    matrix g_mViewProjection : packoffset ( c0 ) ; 
} ; 

cbuffer cbPerFrame : register ( b2 ) 
{ 
    matrix g_mView : packoffset ( c0 ) ; 
    matrix g_mProjection : packoffset ( c4 ) ; 
    matrix g_mProjectionInv : packoffset ( c8 ) ; 
    matrix g_mViewProjectionInvViewport : packoffset ( c12 ) ; 
    float4 g_AmbientColorUp : packoffset ( c16 ) ; 
    float4 g_AmbientColorDown : packoffset ( c17 ) ; 
    float3 g_vCameraPos : packoffset ( c18 ) ; 
    float g_fAlphaTest : packoffset ( c18 . w ) ; 
    uint g_uNumLights : packoffset ( c19 ) ; 
    uint g_uNumSpotLights : packoffset ( c19 . y ) ; 
    uint g_uWindowWidth : packoffset ( c19 . z ) ; 
    uint g_uWindowHeight : packoffset ( c19 . w ) ; 
    uint g_uMaxNumLightsPerTile : packoffset ( c20 ) ; 
    uint g_uMaxNumElementsPerTile : packoffset ( c20 . y ) ; 
    uint g_uNumTilesX : packoffset ( c20 . z ) ; 
    uint g_uNumTilesY : packoffset ( c20 . w ) ; 
    uint g_uMaxVPLs : packoffset ( c21 ) ; 
    uint g_uMaxNumVPLsPerTile : packoffset ( c21 . y ) ; 
    uint g_uMaxNumVPLElementsPerTile : packoffset ( c21 . z ) ; 
    float g_fVPLSpotStrength : packoffset ( c21 . w ) ; 
    float g_fVPLSpotRadius : packoffset ( c22 ) ; 
    float g_fVPLPointStrength : packoffset ( c22 . y ) ; 
    float g_fVPLPointRadius : packoffset ( c22 . z ) ; 
    float g_fVPLRemoveBackFaceContrib : packoffset ( c22 . w ) ; 
    float g_fVPLColorThreshold : packoffset ( c23 ) ; 
    float g_fVPLBrightnessThreshold : packoffset ( c23 . y ) ; 
    float g_fPerFramePad1 : packoffset ( c23 . z ) ; 
    float g_fPerFramePad2 : packoffset ( c23 . w ) ; 
} ; 

cbuffer cbShadowConstants : register ( b3 ) 
{ 
    matrix g_mPointShadowViewProj [ 12 ] [ 6 ] ; 
    matrix g_mSpotShadowViewProj [ 12 ] ; 
    float4 g_ShadowBias ; 
} ; 

cbuffer cbVPLConstants : register ( b4 ) 
{ 
    uint g_uNumVPLs ; 
    uint g_uVPLPad [ 3 ] ; 
} ; 

struct VPLData 
{ 
    float4 Direction ; 
    float4 Color ; 
    float4 SourceLightDirection ; 
} ; 

#line 157
SamplerState g_Sampler : register ( s0 ) ; 
SamplerComparisonState g_ShadowSampler : register ( s1 ) ; 

#line 166
float4 ConvertProjToView ( float4 p ) 
{ 
    p = mul ( p , g_mProjectionInv ) ; 
    p /= p . w ; 
    return p ; 
} 

#line 174
float ConvertProjDepthToView ( float z ) 
{ 
    z = 1.f / ( z * g_mProjectionInv . _34 + g_mProjectionInv . _44 ) ; 
    return z ; 
} 

uint GetTileIndex ( float2 ScreenPos ) 
{ 
    float fTileRes = ( float ) 16 ; 
    uint nTileIdx = floor ( ScreenPos . x / fTileRes ) + floor ( ScreenPos . y / fTileRes ) * g_uNumTilesX ; 
    return nTileIdx ; 
} 

#line 189
void GetLightListInfo ( in Buffer < uint > PerTileLightIndexBuffer , in uint uMaxNumLightsPerTile , in uint uMaxNumElementsPerTile , in float4 SVPosition , out uint uFirstLightIndex , out uint uNumLights ) 
{ 
    uint nTileIndex = GetTileIndex ( SVPosition . xy ) ; 
    uint nStartIndex = uMaxNumElementsPerTile * nTileIndex ; 
    
#line 195
    uint uHalfZBitsHigh = PerTileLightIndexBuffer [ nStartIndex ] ; 
    uint uHalfZBitsLow = PerTileLightIndexBuffer [ nStartIndex + 1 ] ; 
    uint uHalfZBits = ( uHalfZBitsHigh << 16 ) | uHalfZBitsLow ; 
    float fHalfZ = asfloat ( uHalfZBits ) ; 
    
    float fViewPosZ = ConvertProjDepthToView ( SVPosition . z ) ; 
    
    uFirstLightIndex = ( fViewPosZ < fHalfZ ) ? ( nStartIndex + 4 ) : ( nStartIndex + 4 + uMaxNumLightsPerTile ) ; 
    uNumLights = ( fViewPosZ < fHalfZ ) ? PerTileLightIndexBuffer [ nStartIndex + 2 ] : PerTileLightIndexBuffer [ nStartIndex + 3 ] ; 
} 

float4 ConvertNumberOfLightsToGrayscale ( uint nNumLightsInThisTile , uint uMaxNumLightsPerTile ) 
{ 
    float fPercentOfMax = ( float ) nNumLightsInThisTile / ( float ) uMaxNumLightsPerTile ; 
    return float4 ( fPercentOfMax , fPercentOfMax , fPercentOfMax , 1.0f ) ; 
} 

float4 ConvertNumberOfLightsToRadarColor ( uint nNumLightsInThisTile , uint uMaxNumLightsPerTile ) 
{ 
    
    if ( nNumLightsInThisTile == 0 ) return float4 ( 0 , 0 , 0 , 1 ) ; 
    
    else if ( nNumLightsInThisTile == uMaxNumLightsPerTile ) return float4 ( 0.847 , 0.745 , 0.921 , 1 ) ; 
    
    else if ( nNumLightsInThisTile > uMaxNumLightsPerTile ) return float4 ( 1 , 1 , 1 , 1 ) ; 
    
    else 
    { 
        
#line 227
        float fLogBase = exp2 ( 0.07142857f * log2 ( ( float ) uMaxNumLightsPerTile ) ) ; 
        
#line 231
        uint nColorIndex = floor ( log2 ( ( float ) nNumLightsInThisTile ) / log2 ( fLogBase ) ) ; 
        return kRadarColors [ nColorIndex ] ; 
    } 
} 


#line 54 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\TilingForward.hlsl"


#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\TilingCommonHeader.h"


#line 53


#line 58




#line 84






#line 93
Buffer < float4 > g_PointLightBufferCenterAndRadius : register ( t0 ) ; 
Buffer < float4 > g_SpotLightBufferCenterAndRadius : register ( t1 ) ; 

#line 100



Texture2D < float > g_DepthTexture : register ( t3 ) ; 

#line 108




Texture2D < float > g_BlendedDepthTexture : register ( t4 ) ; 

#line 115



#line 122
groupshared uint ldsZMax ; 
groupshared uint ldsZMin ; 

#line 126
groupshared uint ldsLightIdxCounterA ; 
groupshared uint ldsLightIdxCounterB ; 
groupshared uint ldsLightIdx [ 2 * 272 ] ; 

#line 131
groupshared uint ldsSpotIdxCounterA ; 
groupshared uint ldsSpotIdxCounterB ; 
groupshared uint ldsSpotIdx [ 2 * 272 ] ; 

#line 140


#line 146


#line 154
float4 CreatePlaneEquation ( float4 b , float4 c ) 
{ 
    float4 n ; 
    
#line 159
    n . xyz = normalize ( cross ( b . xyz , c . xyz ) ) ; 
    
#line 162
    n . w = 0 ; 
    
    return n ; 
} 

#line 169
float GetSignedDistanceFromPlane ( float4 p , float4 eqn ) 
{ 
    
#line 173
    return dot ( eqn . xyz , p . xyz ) ; 
} 


void CalculateMinMaxDepthInLds ( uint3 globalIdx ) 
{ 
    float opaqueDepth = g_DepthTexture . Load ( uint3 ( globalIdx . x , globalIdx . y , 0 ) ) . x ; 
    float opaqueViewPosZ = ConvertProjDepthToView ( opaqueDepth ) ; 
    uint opaqueZ = asuint ( opaqueViewPosZ ) ; 
    
    
    float blendedDepth = g_BlendedDepthTexture . Load ( uint3 ( globalIdx . x , globalIdx . y , 0 ) ) . x ; 
    float blendedViewPosZ = ConvertProjDepthToView ( blendedDepth ) ; 
    uint blendedZ = asuint ( blendedViewPosZ ) ; 
    
#line 189
    if ( blendedDepth != 0.f ) 
    { 
        InterlockedMax ( ldsZMax , opaqueZ ) ; 
        InterlockedMin ( ldsZMin , blendedZ ) ; 
    } 
    
#line 202
    
} 


#line 269



void 

#line 275

DoLightCulling ( in uint3 globalIdx , in uint localIdxFlattened , in uint3 groupIdx , out float fHalfZ ) 
{ 
    if ( localIdxFlattened == 0 ) 
    { 
        ldsZMin = 0x7f7fffff ; 
        ldsZMax = 0 ; 
        ldsLightIdxCounterA = 0 ; 
        ldsLightIdxCounterB = 272 ; 
        ldsSpotIdxCounterA = 0 ; 
        ldsSpotIdxCounterB = 272 ; 
        
#line 289
        
        
#line 292
        
    } 
    
    float4 frustumEqn [ 4 ] ; 
    { 
        uint pxm = 16 * groupIdx . x ; 
        uint pym = 16 * groupIdx . y ; 
        uint pxp = 16 * ( groupIdx . x + 1 ) ; 
        uint pyp = 16 * ( groupIdx . y + 1 ) ; 
        
        uint uWindowWidthEvenlyDivisibleByTileRes = 16 * g_uNumTilesX ; 
        uint uWindowHeightEvenlyDivisibleByTileRes = 16 * g_uNumTilesY ; 
        
#line 306
        float4 frustum [ 4 ] ; 
        frustum [ 0 ] = ConvertProjToView ( float4 ( pxm / ( float ) uWindowWidthEvenlyDivisibleByTileRes * 2.f - 1.f , ( uWindowHeightEvenlyDivisibleByTileRes - pym ) / ( float ) uWindowHeightEvenlyDivisibleByTileRes * 2.f - 1.f , 1.f , 1.f ) ) ; 
        frustum [ 1 ] = ConvertProjToView ( float4 ( pxp / ( float ) uWindowWidthEvenlyDivisibleByTileRes * 2.f - 1.f , ( uWindowHeightEvenlyDivisibleByTileRes - pym ) / ( float ) uWindowHeightEvenlyDivisibleByTileRes * 2.f - 1.f , 1.f , 1.f ) ) ; 
        frustum [ 2 ] = ConvertProjToView ( float4 ( pxp / ( float ) uWindowWidthEvenlyDivisibleByTileRes * 2.f - 1.f , ( uWindowHeightEvenlyDivisibleByTileRes - pyp ) / ( float ) uWindowHeightEvenlyDivisibleByTileRes * 2.f - 1.f , 1.f , 1.f ) ) ; 
        frustum [ 3 ] = ConvertProjToView ( float4 ( pxm / ( float ) uWindowWidthEvenlyDivisibleByTileRes * 2.f - 1.f , ( uWindowHeightEvenlyDivisibleByTileRes - pyp ) / ( float ) uWindowHeightEvenlyDivisibleByTileRes * 2.f - 1.f , 1.f , 1.f ) ) ; 
        
#line 316
        for ( uint i = 0 ; i < 4 ; i ++ ) 
        frustumEqn [ i ] = CreatePlaneEquation ( frustum [ i ] , frustum [ ( i + 1 ) & 3 ] ) ; 
    } 
    
    GroupMemoryBarrierWithGroupSync ( ) ; 
    
#line 325
    
    CalculateMinMaxDepthInLds ( globalIdx ) ; 
    
#line 336
    
    
    GroupMemoryBarrierWithGroupSync ( ) ; 
    float maxZ = asfloat ( ldsZMax ) ; 
    float minZ = asfloat ( ldsZMin ) ; 
    fHalfZ = ( minZ + maxZ ) / 2.0f ; 
    
#line 344
    for ( uint i = localIdxFlattened ; i < g_uNumLights ; i += ( 16 * 16 ) ) 
    { 
        float4 center = g_PointLightBufferCenterAndRadius [ i ] ; 
        float r = center . w ; 
        center . xyz = mul ( float4 ( center . xyz , 1 ) , g_mView ) . xyz ; 
        
#line 351
        if ( ( GetSignedDistanceFromPlane ( center , frustumEqn [ 0 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 1 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 2 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 3 ] ) < r ) ) 
        { 
            if ( - center . z + minZ < r && center . z - fHalfZ < r ) 
            { 
                
#line 360
                uint dstIdx = 0 ; 
                InterlockedAdd ( ldsLightIdxCounterA , 1 , dstIdx ) ; 
                ldsLightIdx [ dstIdx ] = i ; 
            } 
            if ( - center . z + fHalfZ < r && center . z - maxZ < r ) 
            { 
                
#line 368
                uint dstIdx = 0 ; 
                InterlockedAdd ( ldsLightIdxCounterB , 1 , dstIdx ) ; 
                ldsLightIdx [ dstIdx ] = i ; 
            } 
        } 
    } 
    
#line 376
    for ( uint j = localIdxFlattened ; j < g_uNumSpotLights ; j += ( 16 * 16 ) ) 
    { 
        float4 center = g_SpotLightBufferCenterAndRadius [ j ] ; 
        float r = center . w ; 
        center . xyz = mul ( float4 ( center . xyz , 1 ) , g_mView ) . xyz ; 
        
#line 383
        if ( ( GetSignedDistanceFromPlane ( center , frustumEqn [ 0 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 1 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 2 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 3 ] ) < r ) ) 
        { 
            if ( - center . z + minZ < r && center . z - fHalfZ < r ) 
            { 
                
#line 392
                uint dstIdx = 0 ; 
                InterlockedAdd ( ldsSpotIdxCounterA , 1 , dstIdx ) ; 
                ldsSpotIdx [ dstIdx ] = j ; 
            } 
            if ( - center . z + fHalfZ < r && center . z - maxZ < r ) 
            { 
                
#line 400
                uint dstIdx = 0 ; 
                InterlockedAdd ( ldsSpotIdxCounterB , 1 , dstIdx ) ; 
                ldsSpotIdx [ dstIdx ] = j ; 
            } 
        } 
    } 
    
#line 444
    
    
    GroupMemoryBarrierWithGroupSync ( ) ; 
    
    
    return ; 
    
#line 452
    
} 



#line 59 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\TilingForward.hlsl"
RWBuffer < uint > g_PerTileLightIndexBufferOut : register ( u0 ) ; 
RWBuffer < uint > g_PerTileSpotIndexBufferOut : register ( u1 ) ; 

#line 66


#line 71
[ numthreads ( 16 , 16 , 1 ) ] 
void CullLightsCS ( uint3 globalIdx : SV_DispatchThreadID , uint3 localIdx : SV_GroupThreadID , uint3 groupIdx : SV_GroupID ) 
{ 
    uint localIdxFlattened = localIdx . x + localIdx . y * 16 ; 
    
#line 79
    float fHalfZ ; 
    DoLightCulling ( globalIdx , localIdxFlattened , groupIdx , fHalfZ ) ; 
    
    { 
        uint tileIdxFlattened = groupIdx . x + groupIdx . y * g_uNumTilesX ; 
        uint startOffset = g_uMaxNumElementsPerTile * tileIdxFlattened ; 
        
        for ( uint i = localIdxFlattened ; i < ldsLightIdxCounterA ; i += ( 16 * 16 ) ) 
        { 
            
            g_PerTileLightIndexBufferOut [ startOffset + i + 4 ] = ldsLightIdx [ i ] ; 
        } 
        
        for ( uint j = localIdxFlattened ; j < ldsLightIdxCounterB - 272 ; j += ( 16 * 16 ) ) 
        { 
            
            g_PerTileLightIndexBufferOut [ startOffset + j + 4 + g_uMaxNumLightsPerTile ] = ldsLightIdx [ j + 272 ] ; 
        } 
        
        if ( localIdxFlattened == 0 ) 
        { 
            
            uint uHalfZBits = asuint ( fHalfZ ) ; 
            uint uHalfZBitsHigh = uHalfZBits >> 16 ; 
            uint uHalfZBitsLow = uHalfZBits & 0x0000FFFF ; 
            g_PerTileLightIndexBufferOut [ startOffset + 0 ] = uHalfZBitsHigh ; 
            g_PerTileLightIndexBufferOut [ startOffset + 1 ] = uHalfZBitsLow ; 
            
#line 108
            g_PerTileLightIndexBufferOut [ startOffset + 2 ] = ldsLightIdxCounterA ; 
            
#line 111
            g_PerTileLightIndexBufferOut [ startOffset + 3 ] = ldsLightIdxCounterB - 272 ; 
        } 
    } 
    
    { 
        uint tileIdxFlattened = groupIdx . x + groupIdx . y * g_uNumTilesX ; 
        uint startOffset = g_uMaxNumElementsPerTile * tileIdxFlattened ; 
        
        for ( uint i = localIdxFlattened ; i < ldsSpotIdxCounterA ; i += ( 16 * 16 ) ) 
        { 
            
            g_PerTileSpotIndexBufferOut [ startOffset + i + 4 ] = ldsSpotIdx [ i ] ; 
        } 
        
        for ( uint j = localIdxFlattened ; j < ldsSpotIdxCounterB - 272 ; j += ( 16 * 16 ) ) 
        { 
            
            g_PerTileSpotIndexBufferOut [ startOffset + j + 4 + g_uMaxNumLightsPerTile ] = ldsSpotIdx [ j + 272 ] ; 
        } 
        
        if ( localIdxFlattened == 0 ) 
        { 
            
            uint uHalfZBits = asuint ( fHalfZ ) ; 
            uint uHalfZBitsHigh = uHalfZBits >> 16 ; 
            uint uHalfZBitsLow = uHalfZBits & 0x0000FFFF ; 
            g_PerTileSpotIndexBufferOut [ startOffset + 0 ] = uHalfZBitsHigh ; 
            g_PerTileSpotIndexBufferOut [ startOffset + 1 ] = uHalfZBitsLow ; 
            
#line 141
            g_PerTileSpotIndexBufferOut [ startOffset + 2 ] = ldsSpotIdxCounterA ; 
            
#line 144
            g_PerTileSpotIndexBufferOut [ startOffset + 3 ] = ldsSpotIdxCounterB - 272 ; 
        } 
    } 
    
#line 183
    
} 
 