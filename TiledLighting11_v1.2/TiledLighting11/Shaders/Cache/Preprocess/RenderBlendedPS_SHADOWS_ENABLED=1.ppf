#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\Transparency.hlsl"


#line 53


#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\CommonHeader.h"


#line 56
static const float4 kRadarColors [ 14 ] = 
{ 
    { 0 , 0.9255 , 0.9255 , 1 } , 
    { 0 , 0.62745 , 0.9647 , 1 } , 
    { 0 , 0 , 0.9647 , 1 } , 
    { 0 , 1 , 0 , 1 } , 
    { 0 , 0.7843 , 0 , 1 } , 
    { 0 , 0.5647 , 0 , 1 } , 
    { 1 , 1 , 0 , 1 } , 
    { 0.90588 , 0.75294 , 0 , 1 } , 
    { 1 , 0.5647 , 0 , 1 } , 
    { 1 , 0 , 0 , 1 } , 
    { 0.8392 , 0 , 0 , 1 } , 
    { 0.75294 , 0 , 0 , 1 } , 
    { 1 , 0 , 1 , 1 } , 
    { 0.6 , 0.3333 , 0.7882 , 1 } , 
} ; 

#line 78




#line 86



#line 92
cbuffer cbPerObject : register ( b0 ) 
{ 
    matrix g_mWorld : packoffset ( c0 ) ; 
} 

cbuffer cbPerCamera : register ( b1 ) 
{ 
    matrix g_mViewProjection : packoffset ( c0 ) ; 
} ; 

cbuffer cbPerFrame : register ( b2 ) 
{ 
    matrix g_mView : packoffset ( c0 ) ; 
    matrix g_mProjection : packoffset ( c4 ) ; 
    matrix g_mProjectionInv : packoffset ( c8 ) ; 
    matrix g_mViewProjectionInvViewport : packoffset ( c12 ) ; 
    float4 g_AmbientColorUp : packoffset ( c16 ) ; 
    float4 g_AmbientColorDown : packoffset ( c17 ) ; 
    float3 g_vCameraPos : packoffset ( c18 ) ; 
    float g_fAlphaTest : packoffset ( c18 . w ) ; 
    uint g_uNumLights : packoffset ( c19 ) ; 
    uint g_uNumSpotLights : packoffset ( c19 . y ) ; 
    uint g_uWindowWidth : packoffset ( c19 . z ) ; 
    uint g_uWindowHeight : packoffset ( c19 . w ) ; 
    uint g_uMaxNumLightsPerTile : packoffset ( c20 ) ; 
    uint g_uMaxNumElementsPerTile : packoffset ( c20 . y ) ; 
    uint g_uNumTilesX : packoffset ( c20 . z ) ; 
    uint g_uNumTilesY : packoffset ( c20 . w ) ; 
    uint g_uMaxVPLs : packoffset ( c21 ) ; 
    uint g_uMaxNumVPLsPerTile : packoffset ( c21 . y ) ; 
    uint g_uMaxNumVPLElementsPerTile : packoffset ( c21 . z ) ; 
    float g_fVPLSpotStrength : packoffset ( c21 . w ) ; 
    float g_fVPLSpotRadius : packoffset ( c22 ) ; 
    float g_fVPLPointStrength : packoffset ( c22 . y ) ; 
    float g_fVPLPointRadius : packoffset ( c22 . z ) ; 
    float g_fVPLRemoveBackFaceContrib : packoffset ( c22 . w ) ; 
    float g_fVPLColorThreshold : packoffset ( c23 ) ; 
    float g_fVPLBrightnessThreshold : packoffset ( c23 . y ) ; 
    float g_fPerFramePad1 : packoffset ( c23 . z ) ; 
    float g_fPerFramePad2 : packoffset ( c23 . w ) ; 
} ; 

cbuffer cbShadowConstants : register ( b3 ) 
{ 
    matrix g_mPointShadowViewProj [ 12 ] [ 6 ] ; 
    matrix g_mSpotShadowViewProj [ 12 ] ; 
    float4 g_ShadowBias ; 
} ; 

cbuffer cbVPLConstants : register ( b4 ) 
{ 
    uint g_uNumVPLs ; 
    uint g_uVPLPad [ 3 ] ; 
} ; 

struct VPLData 
{ 
    float4 Direction ; 
    float4 Color ; 
    float4 SourceLightDirection ; 
} ; 

#line 157
SamplerState g_Sampler : register ( s0 ) ; 
SamplerComparisonState g_ShadowSampler : register ( s1 ) ; 

#line 166
float4 ConvertProjToView ( float4 p ) 
{ 
    p = mul ( p , g_mProjectionInv ) ; 
    p /= p . w ; 
    return p ; 
} 

#line 174
float ConvertProjDepthToView ( float z ) 
{ 
    z = 1.f / ( z * g_mProjectionInv . _34 + g_mProjectionInv . _44 ) ; 
    return z ; 
} 

uint GetTileIndex ( float2 ScreenPos ) 
{ 
    float fTileRes = ( float ) 16 ; 
    uint nTileIdx = floor ( ScreenPos . x / fTileRes ) + floor ( ScreenPos . y / fTileRes ) * g_uNumTilesX ; 
    return nTileIdx ; 
} 

#line 189
void GetLightListInfo ( in Buffer < uint > PerTileLightIndexBuffer , in uint uMaxNumLightsPerTile , in uint uMaxNumElementsPerTile , in float4 SVPosition , out uint uFirstLightIndex , out uint uNumLights ) 
{ 
    uint nTileIndex = GetTileIndex ( SVPosition . xy ) ; 
    uint nStartIndex = uMaxNumElementsPerTile * nTileIndex ; 
    
#line 195
    uint uHalfZBitsHigh = PerTileLightIndexBuffer [ nStartIndex ] ; 
    uint uHalfZBitsLow = PerTileLightIndexBuffer [ nStartIndex + 1 ] ; 
    uint uHalfZBits = ( uHalfZBitsHigh << 16 ) | uHalfZBitsLow ; 
    float fHalfZ = asfloat ( uHalfZBits ) ; 
    
    float fViewPosZ = ConvertProjDepthToView ( SVPosition . z ) ; 
    
    uFirstLightIndex = ( fViewPosZ < fHalfZ ) ? ( nStartIndex + 4 ) : ( nStartIndex + 4 + uMaxNumLightsPerTile ) ; 
    uNumLights = ( fViewPosZ < fHalfZ ) ? PerTileLightIndexBuffer [ nStartIndex + 2 ] : PerTileLightIndexBuffer [ nStartIndex + 3 ] ; 
} 

float4 ConvertNumberOfLightsToGrayscale ( uint nNumLightsInThisTile , uint uMaxNumLightsPerTile ) 
{ 
    float fPercentOfMax = ( float ) nNumLightsInThisTile / ( float ) uMaxNumLightsPerTile ; 
    return float4 ( fPercentOfMax , fPercentOfMax , fPercentOfMax , 1.0f ) ; 
} 

float4 ConvertNumberOfLightsToRadarColor ( uint nNumLightsInThisTile , uint uMaxNumLightsPerTile ) 
{ 
    
    if ( nNumLightsInThisTile == 0 ) return float4 ( 0 , 0 , 0 , 1 ) ; 
    
    else if ( nNumLightsInThisTile == uMaxNumLightsPerTile ) return float4 ( 0.847 , 0.745 , 0.921 , 1 ) ; 
    
    else if ( nNumLightsInThisTile > uMaxNumLightsPerTile ) return float4 ( 1 , 1 , 1 , 1 ) ; 
    
    else 
    { 
        
#line 227
        float fLogBase = exp2 ( 0.07142857f * log2 ( ( float ) uMaxNumLightsPerTile ) ) ; 
        
#line 231
        uint nColorIndex = floor ( log2 ( ( float ) nNumLightsInThisTile ) / log2 ( fLogBase ) ) ; 
        return kRadarColors [ nColorIndex ] ; 
    } 
} 


#line 54 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\Transparency.hlsl"


#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\LightingCommonHeader.h"


#line 56
Texture2D g_PointShadowAtlas : register ( t13 ) ; 
Texture2D g_SpotShadowAtlas : register ( t14 ) ; 

#line 63
int Vector3ToFace ( float3 vec ) 
{ 
    int face = 0 ; 
    float x = vec . x ; 
    float y = vec . y ; 
    float z = vec . z ; 
    if ( ( abs ( x ) > abs ( y ) ) && ( abs ( x ) > abs ( z ) ) ) 
    { 
        if ( x >= 0 ) 
        { 
            face = 0 ; 
        } 
        else 
        { 
            face = 1 ; 
        } 
    } 
    else if ( ( abs ( y ) > abs ( x ) ) && ( abs ( y ) > abs ( z ) ) ) 
    { 
        if ( y >= 0 ) 
        { 
            face = 2 ; 
        } 
        else 
        { 
            face = 3 ; 
        } 
    } 
    else 
    { 
        if ( z >= 0 ) 
        { 
            face = 4 ; 
        } 
        else 
        { 
            face = 5 ; 
        } 
    } 
    
    return face ; 
} 

float FilterShadow ( Texture2D atlas , float3 uv ) 
{ 
    float shadow = 0.0 ; 
    
    static const int kernelLevel = 2 ; 
    static const int kernelWidth = 2 * kernelLevel + 1 ; 
    [ unroll ] for ( int i = - kernelLevel ; i <= kernelLevel ; i ++ ) 
    { 
        [ unroll ] for ( int j = - kernelLevel ; j <= kernelLevel ; j ++ ) 
        { 
            shadow += atlas . SampleCmpLevelZero ( g_ShadowSampler , uv . xy , uv . z , int2 ( i , j ) ) . r ; 
        } 
    } 
    
    shadow /= ( kernelWidth * kernelWidth ) ; 
    
    return shadow ; 
} 

float DoShadow ( uint nShadowIndex , in float3 vPosition , float3 vLightDir , float fDistanceTerm ) 
{ 
    float3 uv = - vLightDir ; 
    uv . z = - uv . z ; 
    
    int face = Vector3ToFace ( uv . xyz ) ; 
    
    float4 shadowTexCoord = mul ( float4 ( vPosition , 1 ) , g_mPointShadowViewProj [ nShadowIndex ] [ face ] ) ; 
    shadowTexCoord . xyz = shadowTexCoord . xyz / shadowTexCoord . w ; 
    
    shadowTexCoord . x = shadowTexCoord . x / 2 + 0.5 ; 
    shadowTexCoord . y = shadowTexCoord . y / - 2 + 0.5 ; 
    
    shadowTexCoord . xy *= g_ShadowBias . xx ; 
    shadowTexCoord . xy += g_ShadowBias . yy ; 
    
    shadowTexCoord . x += face ; 
    shadowTexCoord . x *= rcp ( 6 ) ; 
    
    shadowTexCoord . y += nShadowIndex ; 
    shadowTexCoord . y *= rcp ( 12 ) ; 
    
#line 149
    shadowTexCoord . z -= lerp ( 10.0 , 1.0 , saturate ( 5 * fDistanceTerm ) ) * g_ShadowBias . z ; 
    
    return FilterShadow ( g_PointShadowAtlas , shadowTexCoord . xyz ) ; 
} 

float DoSpotShadow ( uint nShadowIndex , in float3 vPosition ) 
{ 
    float4 shadowTexCoord = mul ( float4 ( vPosition , 1 ) , g_mSpotShadowViewProj [ nShadowIndex ] ) ; 
    shadowTexCoord . xyz = shadowTexCoord . xyz / shadowTexCoord . w ; 
    
    shadowTexCoord . x = shadowTexCoord . x / 2 + 0.5 ; 
    shadowTexCoord . y = shadowTexCoord . y / - 2 + 0.5 ; 
    
    shadowTexCoord . x += nShadowIndex ; 
    shadowTexCoord . x *= rcp ( 12 ) ; 
    
    shadowTexCoord . z -= g_ShadowBias . w ; 
    
    return FilterShadow ( g_SpotShadowAtlas , shadowTexCoord . xyz ) ; 
} 

void DoLighting ( uniform bool bDoShadow , in Buffer < float4 > PointLightBufferCenterAndRadius , in Buffer < float4 > PointLightBufferColor , in uint nLightIndex , in float3 vPosition , in float3 vNorm , in float3 vViewDir , out float3 LightColorDiffuseResult , out float3 LightColorSpecularResult ) 
{ 
    float4 CenterAndRadius = PointLightBufferCenterAndRadius [ nLightIndex ] ; 
    
    float3 vToLight = CenterAndRadius . xyz - vPosition ; 
    float3 vLightDir = normalize ( vToLight ) ; 
    float fLightDistance = length ( vToLight ) ; 
    
    LightColorDiffuseResult = float3 ( 0 , 0 , 0 ) ; 
    LightColorSpecularResult = float3 ( 0 , 0 , 0 ) ; 
    
    float fRad = CenterAndRadius . w ; 
    if ( fLightDistance < fRad ) 
    { 
        float x = fLightDistance / fRad ; 
        
#line 188
        float fFalloff = - 0.05 + 1.05 / ( 1 + 20 * x * x ) ; 
        LightColorDiffuseResult = PointLightBufferColor [ nLightIndex ] . rgb * saturate ( dot ( vLightDir , vNorm ) ) * fFalloff ; 
        
        float3 vHalfAngle = normalize ( vViewDir + vLightDir ) ; 
        LightColorSpecularResult = PointLightBufferColor [ nLightIndex ] . rgb * pow ( saturate ( dot ( vHalfAngle , vNorm ) ) , 8 ) * fFalloff ; 
        
        if ( bDoShadow ) 
        { 
            float fShadowResult = DoShadow ( nLightIndex , vPosition , vLightDir , x ) ; 
            LightColorDiffuseResult *= fShadowResult ; 
            LightColorSpecularResult *= fShadowResult ; 
        } 
    } 
} 

void DoSpotLighting ( uniform bool bDoShadow , in Buffer < float4 > SpotLightBufferCenterAndRadius , in Buffer < float4 > SpotLightBufferColor , in Buffer < float4 > SpotLightBufferSpotParams , in uint nLightIndex , in float3 vPosition , in float3 vNorm , in float3 vViewDir , out float3 LightColorDiffuseResult , out float3 LightColorSpecularResult ) 
{ 
    float4 BoundingSphereCenterAndRadius = SpotLightBufferCenterAndRadius [ nLightIndex ] ; 
    float4 SpotParams = SpotLightBufferSpotParams [ nLightIndex ] ; 
    
#line 209
    float3 SpotLightDir ; 
    SpotLightDir . xy = SpotParams . xy ; 
    SpotLightDir . z = sqrt ( 1 - SpotLightDir . x * SpotLightDir . x - SpotLightDir . y * SpotLightDir . y ) ; 
    
#line 214
    SpotLightDir . z = ( SpotParams . z > 0 ) ? SpotLightDir . z : - SpotLightDir . z ; 
    
#line 218
    float3 LightPosition = BoundingSphereCenterAndRadius . xyz - BoundingSphereCenterAndRadius . w * SpotLightDir ; 
    
    float3 vToLight = LightPosition - vPosition ; 
    float3 vToLightNormalized = normalize ( vToLight ) ; 
    float fLightDistance = length ( vToLight ) ; 
    float fCosineOfCurrentConeAngle = dot ( - vToLightNormalized , SpotLightDir ) ; 
    
    LightColorDiffuseResult = float3 ( 0 , 0 , 0 ) ; 
    LightColorSpecularResult = float3 ( 0 , 0 , 0 ) ; 
    
    float fRad = SpotParams . w ; 
    float fCosineOfConeAngle = ( SpotParams . z > 0 ) ? SpotParams . z : - SpotParams . z ; 
    if ( fLightDistance < fRad && fCosineOfCurrentConeAngle > fCosineOfConeAngle ) 
    { 
        float fRadialAttenuation = ( fCosineOfCurrentConeAngle - fCosineOfConeAngle ) / ( 1.0 - fCosineOfConeAngle ) ; 
        fRadialAttenuation = fRadialAttenuation * fRadialAttenuation ; 
        
        float x = fLightDistance / fRad ; 
        
#line 239
        float fFalloff = - 0.05 + 1.05 / ( 1 + 20 * x * x ) ; 
        LightColorDiffuseResult = SpotLightBufferColor [ nLightIndex ] . rgb * saturate ( dot ( vToLightNormalized , vNorm ) ) * fFalloff * fRadialAttenuation ; 
        
        float3 vHalfAngle = normalize ( vViewDir + vToLightNormalized ) ; 
        LightColorSpecularResult = SpotLightBufferColor [ nLightIndex ] . rgb * pow ( saturate ( dot ( vHalfAngle , vNorm ) ) , 8 ) * fFalloff * fRadialAttenuation ; 
        
        if ( bDoShadow ) 
        { 
            float fShadowResult = DoSpotShadow ( nLightIndex , vPosition ) ; 
            LightColorDiffuseResult *= fShadowResult ; 
            LightColorSpecularResult *= fShadowResult ; 
        } 
    } 
} 

void DoVPLLighting ( in StructuredBuffer < float4 > VPLBufferCenterAndRadius , in StructuredBuffer < VPLData > VPLBufferData , in uint nLightIndex , in float3 vPosition , in float3 vNorm , out float3 LightColorDiffuseResult ) 
{ 
    float4 CenterAndRadius = VPLBufferCenterAndRadius [ nLightIndex ] ; 
    VPLData Data = VPLBufferData [ nLightIndex ] ; 
    
    float3 vToLight = CenterAndRadius . xyz - vPosition ; 
    float3 vLightDir = normalize ( vToLight ) ; 
    float fLightDistance = length ( vToLight ) ; 
    
    LightColorDiffuseResult = float3 ( 0 , 0 , 0 ) ; 
    
    float fRad = CenterAndRadius . w ; 
    float fVPLNormalDotDir = max ( 0 , dot ( Data . Direction . xyz , - vLightDir ) ) ; 
    
    if ( fLightDistance < fRad && fVPLNormalDotDir > 0 ) 
    { 
        float3 LightColor = Data . Color . rgb ; 
        
        float x = fLightDistance / fRad ; 
        float fFalloff = smoothstep ( 1.0 , 0.0 , x ) ; 
        
        float fSourceLightNdotL = dot ( Data . SourceLightDirection . xyz , vNorm ) ; 
        if ( fSourceLightNdotL < 0.0 ) 
        { 
            fSourceLightNdotL = 1.0 + ( fSourceLightNdotL / g_fVPLRemoveBackFaceContrib ) ; 
        } 
        else 
        { 
            fSourceLightNdotL = 1.0 ; 
        } 
        
        LightColorDiffuseResult = LightColor * saturate ( dot ( vLightDir , vNorm ) ) * fFalloff * fVPLNormalDotDir * fSourceLightNdotL ; 
    } 
} 


#line 60 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\Transparency.hlsl"
StructuredBuffer < matrix > g_InstanceTransform : register ( t0 ) ; 

Buffer < float4 > g_PointLightBufferCenterAndRadius : register ( t2 ) ; 
Buffer < float4 > g_PointLightBufferColor : register ( t3 ) ; 
Buffer < uint > g_PerTileLightIndexBuffer : register ( t4 ) ; 

Buffer < float4 > g_SpotLightBufferCenterAndRadius : register ( t5 ) ; 
Buffer < float4 > g_SpotLightBufferColor : register ( t6 ) ; 
Buffer < float4 > g_SpotLightBufferSpotParams : register ( t7 ) ; 
Buffer < uint > g_PerTileSpotIndexBuffer : register ( t8 ) ; 

#line 74
struct VS_INPUT_ALPHA_BLENDED 
{ 
    float3 Position : POSITION ; 
    float3 Normal : NORMAL ; 
    float2 TextureUV : TEXCOORD0 ; 
} ; 

struct VS_OUTPUT_ALPHA_BLENDED 
{ 
    float4 Position : SV_POSITION ; 
    float3 Normal : NORMAL ; 
    float3 PositionWS : TEXCOORD0 ; 
} ; 

struct VS_OUTPUT_ALPHA_BLENDED_DEPTH 
{ 
    float4 Position : SV_POSITION ; 
} ; 

void DoLightingTwoSided ( in uint nLightIndex , in float3 vPosition , in float3 vNorm , in float3 vViewDir , 
out float3 LightColorDiffuseResultFrontFace , out float3 LightColorSpecularResultFrontFace , 
out float3 LightColorDiffuseResultBackFace , out float3 LightColorSpecularResultBackFace ) 
{ 
    float4 CenterAndRadius = g_PointLightBufferCenterAndRadius [ nLightIndex ] ; 
    
    float3 vToLight = CenterAndRadius . xyz - vPosition . xyz ; 
    float3 vLightDir = normalize ( vToLight ) ; 
    float fLightDistance = length ( vToLight ) ; 
    
    LightColorDiffuseResultFrontFace = float3 ( 0 , 0 , 0 ) ; 
    LightColorSpecularResultFrontFace = float3 ( 0 , 0 , 0 ) ; 
    LightColorDiffuseResultBackFace = float3 ( 0 , 0 , 0 ) ; 
    LightColorSpecularResultBackFace = float3 ( 0 , 0 , 0 ) ; 
    
    float fRad = CenterAndRadius . w ; 
    if ( fLightDistance < fRad ) 
    { 
        float x = fLightDistance / fRad ; 
        
#line 115
        float fFalloff = - 0.05 + 1.05 / ( 1 + 20 * x * x ) ; 
        
        float3 LightColor = g_PointLightBufferColor [ nLightIndex ] . rgb ; 
        
        LightColorDiffuseResultFrontFace = LightColor * saturate ( dot ( vLightDir , vNorm ) ) * fFalloff ; 
        
        float3 vHalfAngle = normalize ( vViewDir + vLightDir ) ; 
        LightColorSpecularResultFrontFace = LightColor * pow ( saturate ( dot ( vHalfAngle , vNorm ) ) , 8 ) * fFalloff ; 
        
        LightColorDiffuseResultBackFace = LightColor * saturate ( dot ( vLightDir , - vNorm ) ) * fFalloff ; 
        LightColorSpecularResultBackFace = LightColor * pow ( saturate ( dot ( vHalfAngle , - vNorm ) ) , 8 ) * fFalloff ; 
        
        
        float fShadowResult = DoShadow ( nLightIndex , vPosition , vLightDir , x ) ; 
        LightColorDiffuseResultFrontFace *= fShadowResult ; 
        LightColorSpecularResultFrontFace *= fShadowResult ; 
        LightColorDiffuseResultBackFace *= fShadowResult ; 
        LightColorSpecularResultBackFace *= fShadowResult ; 
        
    } 
} 

void DoSpotLightingTwoSided ( in uint nLightIndex , in float3 vPosition , in float3 vNorm , in float3 vViewDir , 
out float3 LightColorDiffuseResultFrontFace , out float3 LightColorSpecularResultFrontFace , 
out float3 LightColorDiffuseResultBackFace , out float3 LightColorSpecularResultBackFace ) 
{ 
    float4 BoundingSphereCenterAndRadius = g_SpotLightBufferCenterAndRadius [ nLightIndex ] ; 
    float4 SpotParams = g_SpotLightBufferSpotParams [ nLightIndex ] ; 
    
#line 145
    float3 SpotLightDir ; 
    SpotLightDir . xy = SpotParams . xy ; 
    SpotLightDir . z = sqrt ( 1 - SpotLightDir . x * SpotLightDir . x - SpotLightDir . y * SpotLightDir . y ) ; 
    
#line 150
    SpotLightDir . z = ( SpotParams . z > 0 ) ? SpotLightDir . z : - SpotLightDir . z ; 
    
#line 154
    float3 LightPosition = BoundingSphereCenterAndRadius . xyz - BoundingSphereCenterAndRadius . w * SpotLightDir ; 
    
    float3 vToLight = LightPosition - vPosition ; 
    float3 vToLightNormalized = normalize ( vToLight ) ; 
    float fLightDistance = length ( vToLight ) ; 
    float fCosineOfCurrentConeAngle = dot ( - vToLightNormalized , SpotLightDir ) ; 
    
    LightColorDiffuseResultFrontFace = float3 ( 0 , 0 , 0 ) ; 
    LightColorSpecularResultFrontFace = float3 ( 0 , 0 , 0 ) ; 
    LightColorDiffuseResultBackFace = float3 ( 0 , 0 , 0 ) ; 
    LightColorSpecularResultBackFace = float3 ( 0 , 0 , 0 ) ; 
    
    float fRad = SpotParams . w ; 
    float fCosineOfConeAngle = ( SpotParams . z > 0 ) ? SpotParams . z : - SpotParams . z ; 
    if ( fLightDistance < fRad && fCosineOfCurrentConeAngle > fCosineOfConeAngle ) 
    { 
        float fRadialAttenuation = ( fCosineOfCurrentConeAngle - fCosineOfConeAngle ) / ( 1.0 - fCosineOfConeAngle ) ; 
        fRadialAttenuation = fRadialAttenuation * fRadialAttenuation ; 
        
        float x = fLightDistance / fRad ; 
        
#line 177
        float fFalloff = - 0.05 + 1.05 / ( 1 + 20 * x * x ) ; 
        
        float3 LightColor = g_SpotLightBufferColor [ nLightIndex ] . rgb ; 
        
        LightColorDiffuseResultFrontFace = LightColor * saturate ( dot ( vToLightNormalized , vNorm ) ) * fFalloff * fRadialAttenuation ; 
        
        float3 vHalfAngle = normalize ( vViewDir + vToLightNormalized ) ; 
        LightColorSpecularResultFrontFace = LightColor * pow ( saturate ( dot ( vHalfAngle , vNorm ) ) , 8 ) * fFalloff * fRadialAttenuation ; 
        
        LightColorDiffuseResultBackFace = LightColor * saturate ( dot ( vToLightNormalized , - vNorm ) ) * fFalloff * fRadialAttenuation ; 
        LightColorSpecularResultBackFace = LightColor * pow ( saturate ( dot ( vHalfAngle , - vNorm ) ) , 8 ) * fFalloff * fRadialAttenuation ; 
        
        
        float fShadowResult = DoSpotShadow ( nLightIndex , vPosition ) ; 
        LightColorDiffuseResultFrontFace *= fShadowResult ; 
        LightColorSpecularResultFrontFace *= fShadowResult ; 
        LightColorDiffuseResultBackFace *= fShadowResult ; 
        LightColorSpecularResultBackFace *= fShadowResult ; 
        
    } 
} 

#line 202
VS_OUTPUT_ALPHA_BLENDED_DEPTH RenderBlendedDepthVS ( VS_INPUT_ALPHA_BLENDED Input , uint InstanceID : SV_InstanceID ) 
{ 
    VS_OUTPUT_ALPHA_BLENDED_DEPTH Output ; 
    
    matrix mWorld = g_InstanceTransform [ InstanceID ] ; 
    
#line 209
    float4 vWorldPos = mul ( float4 ( Input . Position , 1 ) , mWorld ) ; 
    Output . Position = mul ( vWorldPos , g_mViewProjection ) ; 
    
    return Output ; 
} 

#line 219
VS_OUTPUT_ALPHA_BLENDED RenderBlendedVS ( VS_INPUT_ALPHA_BLENDED Input , uint InstanceID : SV_InstanceID ) 
{ 
    VS_OUTPUT_ALPHA_BLENDED Output ; 
    
    matrix mWorld = g_InstanceTransform [ InstanceID ] ; 
    
#line 226
    float4 vWorldPos = mul ( float4 ( Input . Position , 1 ) , mWorld ) ; 
    Output . Position = mul ( vWorldPos , g_mViewProjection ) ; 
    
#line 230
    Output . PositionWS = vWorldPos . xyz ; 
    Output . Normal = mul ( Input . Normal , ( float3x3 ) mWorld ) ; 
    
    return Output ; 
} 

#line 239
float4 RenderBlendedPS ( VS_OUTPUT_ALPHA_BLENDED Input ) : SV_TARGET 
{ 
    float3 vPositionWS = Input . PositionWS ; 
    
    float3 AccumDiffuseFrontFace = float3 ( 0 , 0 , 0 ) ; 
    float3 AccumSpecularFrontFace = float3 ( 0 , 0 , 0 ) ; 
    float3 AccumDiffuseBackFace = float3 ( 0 , 0 , 0 ) ; 
    float3 AccumSpecularBackFace = float3 ( 0 , 0 , 0 ) ; 
    
    float3 vNorm = Input . Normal ; 
    vNorm = normalize ( vNorm ) ; 
    
    float3 vViewDir = normalize ( g_vCameraPos - vPositionWS ) ; 
    
#line 254
    { 
        uint nStartIndex , nLightCount ; 
        GetLightListInfo ( g_PerTileLightIndexBuffer , g_uMaxNumLightsPerTile , g_uMaxNumElementsPerTile , Input . Position , nStartIndex , nLightCount ) ; 
        
        [ loop ] 
        for ( uint i = nStartIndex ; i < nStartIndex + nLightCount ; i ++ ) 
        { 
            uint nLightIndex = g_PerTileLightIndexBuffer [ i ] ; 
            
            float3 LightColorDiffuseResultFrontFace ; 
            float3 LightColorSpecularResultFrontFace ; 
            float3 LightColorDiffuseResultBackFace ; 
            float3 LightColorSpecularResultBackFace ; 
            DoLightingTwoSided ( nLightIndex , vPositionWS , vNorm , vViewDir , 
            LightColorDiffuseResultFrontFace , LightColorSpecularResultFrontFace , 
            LightColorDiffuseResultBackFace , LightColorSpecularResultBackFace ) ; 
            
            AccumDiffuseFrontFace += LightColorDiffuseResultFrontFace ; 
            AccumSpecularFrontFace += LightColorSpecularResultFrontFace ; 
            AccumDiffuseBackFace += LightColorDiffuseResultBackFace ; 
            AccumSpecularBackFace += LightColorSpecularResultBackFace ; 
        } 
    } 
    
#line 279
    { 
        uint nStartIndex , nLightCount ; 
        GetLightListInfo ( g_PerTileSpotIndexBuffer , g_uMaxNumLightsPerTile , g_uMaxNumElementsPerTile , Input . Position , nStartIndex , nLightCount ) ; 
        
        [ loop ] 
        for ( uint i = nStartIndex ; i < nStartIndex + nLightCount ; i ++ ) 
        { 
            uint nLightIndex = g_PerTileSpotIndexBuffer [ i ] ; 
            
            float3 LightColorDiffuseResultFrontFace ; 
            float3 LightColorSpecularResultFrontFace ; 
            float3 LightColorDiffuseResultBackFace ; 
            float3 LightColorSpecularResultBackFace ; 
            DoSpotLightingTwoSided ( nLightIndex , vPositionWS , vNorm , vViewDir , 
            LightColorDiffuseResultFrontFace , LightColorSpecularResultFrontFace , 
            LightColorDiffuseResultBackFace , LightColorSpecularResultBackFace ) ; 
            
            AccumDiffuseFrontFace += LightColorDiffuseResultFrontFace ; 
            AccumSpecularFrontFace += LightColorSpecularResultFrontFace ; 
            AccumDiffuseBackFace += LightColorDiffuseResultBackFace ; 
            AccumSpecularBackFace += LightColorSpecularResultBackFace ; 
        } 
    } 
    
#line 304
    AccumDiffuseFrontFace *= 2 ; 
    AccumSpecularFrontFace *= 8 ; 
    AccumDiffuseBackFace *= 2 ; 
    AccumSpecularBackFace *= 8 ; 
    
#line 310
    float fAmbientBlendFrontFace = 0.5f * vNorm . y + 0.5 ; 
    float3 AmbientFrontFace = g_AmbientColorUp . rgb * fAmbientBlendFrontFace + g_AmbientColorDown . rgb * ( 1 - fAmbientBlendFrontFace ) ; 
    
#line 314
    float fAmbientBlendBackFace = 0.5f * - vNorm . y + 0.5 ; 
    float3 AmbientBackFace = g_AmbientColorUp . rgb * fAmbientBlendBackFace + g_AmbientColorDown . rgb * ( 1 - fAmbientBlendBackFace ) ; 
    
#line 318
    float3 DiffuseAndAmbientFrontFace = AccumDiffuseFrontFace + AmbientFrontFace ; 
    float3 DiffuseAndAmbientBackFace = AccumDiffuseBackFace + AmbientBackFace ; 
    float BackFaceWeight = 0.5 ; 
    float3 TotalLighting = DiffuseAndAmbientFrontFace + AccumSpecularFrontFace + ( BackFaceWeight * ( DiffuseAndAmbientBackFace + AccumSpecularBackFace ) ) ; 
    
    return float4 ( TotalLighting , 0.5 ) ; 
} 
 