#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\TilingDeferred.hlsl"


#line 53


#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\CommonHeader.h"


#line 56
static const float4 kRadarColors [ 14 ] = 
{ 
    { 0 , 0.9255 , 0.9255 , 1 } , 
    { 0 , 0.62745 , 0.9647 , 1 } , 
    { 0 , 0 , 0.9647 , 1 } , 
    { 0 , 1 , 0 , 1 } , 
    { 0 , 0.7843 , 0 , 1 } , 
    { 0 , 0.5647 , 0 , 1 } , 
    { 1 , 1 , 0 , 1 } , 
    { 0.90588 , 0.75294 , 0 , 1 } , 
    { 1 , 0.5647 , 0 , 1 } , 
    { 1 , 0 , 0 , 1 } , 
    { 0.8392 , 0 , 0 , 1 } , 
    { 0.75294 , 0 , 0 , 1 } , 
    { 1 , 0 , 1 , 1 } , 
    { 0.6 , 0.3333 , 0.7882 , 1 } , 
} ; 

#line 78




#line 86



#line 92
cbuffer cbPerObject : register ( b0 ) 
{ 
    matrix g_mWorld : packoffset ( c0 ) ; 
} 

cbuffer cbPerCamera : register ( b1 ) 
{ 
    matrix g_mViewProjection : packoffset ( c0 ) ; 
} ; 

cbuffer cbPerFrame : register ( b2 ) 
{ 
    matrix g_mView : packoffset ( c0 ) ; 
    matrix g_mProjection : packoffset ( c4 ) ; 
    matrix g_mProjectionInv : packoffset ( c8 ) ; 
    matrix g_mViewProjectionInvViewport : packoffset ( c12 ) ; 
    float4 g_AmbientColorUp : packoffset ( c16 ) ; 
    float4 g_AmbientColorDown : packoffset ( c17 ) ; 
    float3 g_vCameraPos : packoffset ( c18 ) ; 
    float g_fAlphaTest : packoffset ( c18 . w ) ; 
    uint g_uNumLights : packoffset ( c19 ) ; 
    uint g_uNumSpotLights : packoffset ( c19 . y ) ; 
    uint g_uWindowWidth : packoffset ( c19 . z ) ; 
    uint g_uWindowHeight : packoffset ( c19 . w ) ; 
    uint g_uMaxNumLightsPerTile : packoffset ( c20 ) ; 
    uint g_uMaxNumElementsPerTile : packoffset ( c20 . y ) ; 
    uint g_uNumTilesX : packoffset ( c20 . z ) ; 
    uint g_uNumTilesY : packoffset ( c20 . w ) ; 
    uint g_uMaxVPLs : packoffset ( c21 ) ; 
    uint g_uMaxNumVPLsPerTile : packoffset ( c21 . y ) ; 
    uint g_uMaxNumVPLElementsPerTile : packoffset ( c21 . z ) ; 
    float g_fVPLSpotStrength : packoffset ( c21 . w ) ; 
    float g_fVPLSpotRadius : packoffset ( c22 ) ; 
    float g_fVPLPointStrength : packoffset ( c22 . y ) ; 
    float g_fVPLPointRadius : packoffset ( c22 . z ) ; 
    float g_fVPLRemoveBackFaceContrib : packoffset ( c22 . w ) ; 
    float g_fVPLColorThreshold : packoffset ( c23 ) ; 
    float g_fVPLBrightnessThreshold : packoffset ( c23 . y ) ; 
    float g_fPerFramePad1 : packoffset ( c23 . z ) ; 
    float g_fPerFramePad2 : packoffset ( c23 . w ) ; 
} ; 

cbuffer cbShadowConstants : register ( b3 ) 
{ 
    matrix g_mPointShadowViewProj [ 12 ] [ 6 ] ; 
    matrix g_mSpotShadowViewProj [ 12 ] ; 
    float4 g_ShadowBias ; 
} ; 

cbuffer cbVPLConstants : register ( b4 ) 
{ 
    uint g_uNumVPLs ; 
    uint g_uVPLPad [ 3 ] ; 
} ; 

struct VPLData 
{ 
    float4 Direction ; 
    float4 Color ; 
    float4 SourceLightDirection ; 
} ; 

#line 157
SamplerState g_Sampler : register ( s0 ) ; 
SamplerComparisonState g_ShadowSampler : register ( s1 ) ; 

#line 166
float4 ConvertProjToView ( float4 p ) 
{ 
    p = mul ( p , g_mProjectionInv ) ; 
    p /= p . w ; 
    return p ; 
} 

#line 174
float ConvertProjDepthToView ( float z ) 
{ 
    z = 1.f / ( z * g_mProjectionInv . _34 + g_mProjectionInv . _44 ) ; 
    return z ; 
} 

uint GetTileIndex ( float2 ScreenPos ) 
{ 
    float fTileRes = ( float ) 16 ; 
    uint nTileIdx = floor ( ScreenPos . x / fTileRes ) + floor ( ScreenPos . y / fTileRes ) * g_uNumTilesX ; 
    return nTileIdx ; 
} 

#line 189
void GetLightListInfo ( in Buffer < uint > PerTileLightIndexBuffer , in uint uMaxNumLightsPerTile , in uint uMaxNumElementsPerTile , in float4 SVPosition , out uint uFirstLightIndex , out uint uNumLights ) 
{ 
    uint nTileIndex = GetTileIndex ( SVPosition . xy ) ; 
    uint nStartIndex = uMaxNumElementsPerTile * nTileIndex ; 
    
#line 195
    uint uHalfZBitsHigh = PerTileLightIndexBuffer [ nStartIndex ] ; 
    uint uHalfZBitsLow = PerTileLightIndexBuffer [ nStartIndex + 1 ] ; 
    uint uHalfZBits = ( uHalfZBitsHigh << 16 ) | uHalfZBitsLow ; 
    float fHalfZ = asfloat ( uHalfZBits ) ; 
    
    float fViewPosZ = ConvertProjDepthToView ( SVPosition . z ) ; 
    
    uFirstLightIndex = ( fViewPosZ < fHalfZ ) ? ( nStartIndex + 4 ) : ( nStartIndex + 4 + uMaxNumLightsPerTile ) ; 
    uNumLights = ( fViewPosZ < fHalfZ ) ? PerTileLightIndexBuffer [ nStartIndex + 2 ] : PerTileLightIndexBuffer [ nStartIndex + 3 ] ; 
} 

float4 ConvertNumberOfLightsToGrayscale ( uint nNumLightsInThisTile , uint uMaxNumLightsPerTile ) 
{ 
    float fPercentOfMax = ( float ) nNumLightsInThisTile / ( float ) uMaxNumLightsPerTile ; 
    return float4 ( fPercentOfMax , fPercentOfMax , fPercentOfMax , 1.0f ) ; 
} 

float4 ConvertNumberOfLightsToRadarColor ( uint nNumLightsInThisTile , uint uMaxNumLightsPerTile ) 
{ 
    
    if ( nNumLightsInThisTile == 0 ) return float4 ( 0 , 0 , 0 , 1 ) ; 
    
    else if ( nNumLightsInThisTile == uMaxNumLightsPerTile ) return float4 ( 0.847 , 0.745 , 0.921 , 1 ) ; 
    
    else if ( nNumLightsInThisTile > uMaxNumLightsPerTile ) return float4 ( 1 , 1 , 1 , 1 ) ; 
    
    else 
    { 
        
#line 227
        float fLogBase = exp2 ( 0.07142857f * log2 ( ( float ) uMaxNumLightsPerTile ) ) ; 
        
#line 231
        uint nColorIndex = floor ( log2 ( ( float ) nNumLightsInThisTile ) / log2 ( fLogBase ) ) ; 
        return kRadarColors [ nColorIndex ] ; 
    } 
} 


#line 54 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\TilingDeferred.hlsl"


#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\TilingCommonHeader.h"


#line 53


#line 58




#line 76





#line 88


#line 93
Buffer < float4 > g_PointLightBufferCenterAndRadius : register ( t0 ) ; 
Buffer < float4 > g_SpotLightBufferCenterAndRadius : register ( t1 ) ; 

#line 100


#line 106

Texture2DMS < float , 2 > g_DepthTexture : register ( t3 ) ; 


#line 116


#line 122
groupshared uint ldsZMax ; 
groupshared uint ldsZMin ; 

#line 126
groupshared uint ldsLightIdxCounterA ; 
groupshared uint ldsLightIdxCounterB ; 
groupshared uint ldsLightIdx [ 2 * 272 ] ; 

#line 131
groupshared uint ldsSpotIdxCounterA ; 
groupshared uint ldsSpotIdxCounterB ; 
groupshared uint ldsSpotIdx [ 2 * 272 ] ; 

#line 140




groupshared uint ldsEdgePixelIdxCounter ; 
groupshared uint ldsEdgePixelIdx [ ( 16 * 16 ) ] ; 


#line 154
float4 CreatePlaneEquation ( float4 b , float4 c ) 
{ 
    float4 n ; 
    
#line 159
    n . xyz = normalize ( cross ( b . xyz , c . xyz ) ) ; 
    
#line 162
    n . w = 0 ; 
    
    return n ; 
} 

#line 169
float GetSignedDistanceFromPlane ( float4 p , float4 eqn ) 
{ 
    
#line 173
    return dot ( eqn . xyz , p . xyz ) ; 
} 

#line 204



bool CalculateMinMaxDepthInLdsMSAA ( uint3 globalIdx , uint depthBufferNumSamples ) 
{ 
    float minZForThisPixel = 3.402823466e+38F ; 
    float maxZForThisPixel = 0.f ; 
    
    float opaqueDepth0 = g_DepthTexture . Load ( uint2 ( globalIdx . x , globalIdx . y ) , 0 ) . x ; 
    float opaqueViewPosZ0 = ConvertProjDepthToView ( opaqueDepth0 ) ; 
    
#line 226
    
    
    if ( opaqueDepth0 != 0.f ) 
    { 
        maxZForThisPixel = max ( maxZForThisPixel , opaqueViewPosZ0 ) ; 
        minZForThisPixel = min ( minZForThisPixel , opaqueViewPosZ0 ) ; 
    } 
    
    
    for ( uint sampleIdx = 1 ; sampleIdx < depthBufferNumSamples ; sampleIdx ++ ) 
    { 
        float opaqueDepth = g_DepthTexture . Load ( uint2 ( globalIdx . x , globalIdx . y ) , sampleIdx ) . x ; 
        float opaqueViewPosZ = ConvertProjDepthToView ( opaqueDepth ) ; 
        
#line 251
        
        
        if ( opaqueDepth != 0.f ) 
        { 
            maxZForThisPixel = max ( maxZForThisPixel , opaqueViewPosZ ) ; 
            minZForThisPixel = min ( minZForThisPixel , opaqueViewPosZ ) ; 
        } 
        
    } 
    
    uint zMaxForThisPixel = asuint ( maxZForThisPixel ) ; 
    uint zMinForThisPixel = asuint ( minZForThisPixel ) ; 
    InterlockedMax ( ldsZMax , zMaxForThisPixel ) ; 
    InterlockedMin ( ldsZMin , zMinForThisPixel ) ; 
    
#line 267
    return ( ( maxZForThisPixel - minZForThisPixel ) > 50.0f ) ; 
} 


#line 273

bool 

DoLightCulling ( in uint3 globalIdx , in uint localIdxFlattened , in uint3 groupIdx , out float fHalfZ ) 
{ 
    if ( localIdxFlattened == 0 ) 
    { 
        ldsZMin = 0x7f7fffff ; 
        ldsZMax = 0 ; 
        ldsLightIdxCounterA = 0 ; 
        ldsLightIdxCounterB = 272 ; 
        ldsSpotIdxCounterA = 0 ; 
        ldsSpotIdxCounterB = 272 ; 
        
#line 289
        
        
        ldsEdgePixelIdxCounter = 0 ; 
        
    } 
    
    float4 frustumEqn [ 4 ] ; 
    { 
        uint pxm = 16 * groupIdx . x ; 
        uint pym = 16 * groupIdx . y ; 
        uint pxp = 16 * ( groupIdx . x + 1 ) ; 
        uint pyp = 16 * ( groupIdx . y + 1 ) ; 
        
        uint uWindowWidthEvenlyDivisibleByTileRes = 16 * g_uNumTilesX ; 
        uint uWindowHeightEvenlyDivisibleByTileRes = 16 * g_uNumTilesY ; 
        
#line 306
        float4 frustum [ 4 ] ; 
        frustum [ 0 ] = ConvertProjToView ( float4 ( pxm / ( float ) uWindowWidthEvenlyDivisibleByTileRes * 2.f - 1.f , ( uWindowHeightEvenlyDivisibleByTileRes - pym ) / ( float ) uWindowHeightEvenlyDivisibleByTileRes * 2.f - 1.f , 1.f , 1.f ) ) ; 
        frustum [ 1 ] = ConvertProjToView ( float4 ( pxp / ( float ) uWindowWidthEvenlyDivisibleByTileRes * 2.f - 1.f , ( uWindowHeightEvenlyDivisibleByTileRes - pym ) / ( float ) uWindowHeightEvenlyDivisibleByTileRes * 2.f - 1.f , 1.f , 1.f ) ) ; 
        frustum [ 2 ] = ConvertProjToView ( float4 ( pxp / ( float ) uWindowWidthEvenlyDivisibleByTileRes * 2.f - 1.f , ( uWindowHeightEvenlyDivisibleByTileRes - pyp ) / ( float ) uWindowHeightEvenlyDivisibleByTileRes * 2.f - 1.f , 1.f , 1.f ) ) ; 
        frustum [ 3 ] = ConvertProjToView ( float4 ( pxm / ( float ) uWindowWidthEvenlyDivisibleByTileRes * 2.f - 1.f , ( uWindowHeightEvenlyDivisibleByTileRes - pyp ) / ( float ) uWindowHeightEvenlyDivisibleByTileRes * 2.f - 1.f , 1.f , 1.f ) ) ; 
        
#line 316
        for ( uint i = 0 ; i < 4 ; i ++ ) 
        frustumEqn [ i ] = CreatePlaneEquation ( frustum [ i ] , frustum [ ( i + 1 ) & 3 ] ) ; 
    } 
    
    GroupMemoryBarrierWithGroupSync ( ) ; 
    
#line 327
    
    
#line 332
    
    uint depthBufferNumSamples = 2 ; 
    bool bIsEdge = CalculateMinMaxDepthInLdsMSAA ( globalIdx , depthBufferNumSamples ) ; 
    
    
    
    GroupMemoryBarrierWithGroupSync ( ) ; 
    float maxZ = asfloat ( ldsZMax ) ; 
    float minZ = asfloat ( ldsZMin ) ; 
    fHalfZ = ( minZ + maxZ ) / 2.0f ; 
    
#line 344
    for ( uint i = localIdxFlattened ; i < g_uNumLights ; i += ( 16 * 16 ) ) 
    { 
        float4 center = g_PointLightBufferCenterAndRadius [ i ] ; 
        float r = center . w ; 
        center . xyz = mul ( float4 ( center . xyz , 1 ) , g_mView ) . xyz ; 
        
#line 351
        if ( ( GetSignedDistanceFromPlane ( center , frustumEqn [ 0 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 1 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 2 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 3 ] ) < r ) ) 
        { 
            if ( - center . z + minZ < r && center . z - fHalfZ < r ) 
            { 
                
#line 360
                uint dstIdx = 0 ; 
                InterlockedAdd ( ldsLightIdxCounterA , 1 , dstIdx ) ; 
                ldsLightIdx [ dstIdx ] = i ; 
            } 
            if ( - center . z + fHalfZ < r && center . z - maxZ < r ) 
            { 
                
#line 368
                uint dstIdx = 0 ; 
                InterlockedAdd ( ldsLightIdxCounterB , 1 , dstIdx ) ; 
                ldsLightIdx [ dstIdx ] = i ; 
            } 
        } 
    } 
    
#line 376
    for ( uint j = localIdxFlattened ; j < g_uNumSpotLights ; j += ( 16 * 16 ) ) 
    { 
        float4 center = g_SpotLightBufferCenterAndRadius [ j ] ; 
        float r = center . w ; 
        center . xyz = mul ( float4 ( center . xyz , 1 ) , g_mView ) . xyz ; 
        
#line 383
        if ( ( GetSignedDistanceFromPlane ( center , frustumEqn [ 0 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 1 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 2 ] ) < r ) && 
        ( GetSignedDistanceFromPlane ( center , frustumEqn [ 3 ] ) < r ) ) 
        { 
            if ( - center . z + minZ < r && center . z - fHalfZ < r ) 
            { 
                
#line 392
                uint dstIdx = 0 ; 
                InterlockedAdd ( ldsSpotIdxCounterA , 1 , dstIdx ) ; 
                ldsSpotIdx [ dstIdx ] = j ; 
            } 
            if ( - center . z + fHalfZ < r && center . z - maxZ < r ) 
            { 
                
#line 400
                uint dstIdx = 0 ; 
                InterlockedAdd ( ldsSpotIdxCounterB , 1 , dstIdx ) ; 
                ldsSpotIdx [ dstIdx ] = j ; 
            } 
        } 
    } 
    
#line 444
    
    
    GroupMemoryBarrierWithGroupSync ( ) ; 
    
#line 450
    
    return bIsEdge ; 
    
} 



#line 55 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\TilingDeferred.hlsl"


#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\LightingCommonHeader.h"


#line 56
Texture2D g_PointShadowAtlas : register ( t13 ) ; 
Texture2D g_SpotShadowAtlas : register ( t14 ) ; 

#line 63
int Vector3ToFace ( float3 vec ) 
{ 
    int face = 0 ; 
    float x = vec . x ; 
    float y = vec . y ; 
    float z = vec . z ; 
    if ( ( abs ( x ) > abs ( y ) ) && ( abs ( x ) > abs ( z ) ) ) 
    { 
        if ( x >= 0 ) 
        { 
            face = 0 ; 
        } 
        else 
        { 
            face = 1 ; 
        } 
    } 
    else if ( ( abs ( y ) > abs ( x ) ) && ( abs ( y ) > abs ( z ) ) ) 
    { 
        if ( y >= 0 ) 
        { 
            face = 2 ; 
        } 
        else 
        { 
            face = 3 ; 
        } 
    } 
    else 
    { 
        if ( z >= 0 ) 
        { 
            face = 4 ; 
        } 
        else 
        { 
            face = 5 ; 
        } 
    } 
    
    return face ; 
} 

float FilterShadow ( Texture2D atlas , float3 uv ) 
{ 
    float shadow = 0.0 ; 
    
    static const int kernelLevel = 2 ; 
    static const int kernelWidth = 2 * kernelLevel + 1 ; 
    [ unroll ] for ( int i = - kernelLevel ; i <= kernelLevel ; i ++ ) 
    { 
        [ unroll ] for ( int j = - kernelLevel ; j <= kernelLevel ; j ++ ) 
        { 
            shadow += atlas . SampleCmpLevelZero ( g_ShadowSampler , uv . xy , uv . z , int2 ( i , j ) ) . r ; 
        } 
    } 
    
    shadow /= ( kernelWidth * kernelWidth ) ; 
    
    return shadow ; 
} 

float DoShadow ( uint nShadowIndex , in float3 vPosition , float3 vLightDir , float fDistanceTerm ) 
{ 
    float3 uv = - vLightDir ; 
    uv . z = - uv . z ; 
    
    int face = Vector3ToFace ( uv . xyz ) ; 
    
    float4 shadowTexCoord = mul ( float4 ( vPosition , 1 ) , g_mPointShadowViewProj [ nShadowIndex ] [ face ] ) ; 
    shadowTexCoord . xyz = shadowTexCoord . xyz / shadowTexCoord . w ; 
    
    shadowTexCoord . x = shadowTexCoord . x / 2 + 0.5 ; 
    shadowTexCoord . y = shadowTexCoord . y / - 2 + 0.5 ; 
    
    shadowTexCoord . xy *= g_ShadowBias . xx ; 
    shadowTexCoord . xy += g_ShadowBias . yy ; 
    
    shadowTexCoord . x += face ; 
    shadowTexCoord . x *= rcp ( 6 ) ; 
    
    shadowTexCoord . y += nShadowIndex ; 
    shadowTexCoord . y *= rcp ( 12 ) ; 
    
#line 149
    shadowTexCoord . z -= lerp ( 10.0 , 1.0 , saturate ( 5 * fDistanceTerm ) ) * g_ShadowBias . z ; 
    
    return FilterShadow ( g_PointShadowAtlas , shadowTexCoord . xyz ) ; 
} 

float DoSpotShadow ( uint nShadowIndex , in float3 vPosition ) 
{ 
    float4 shadowTexCoord = mul ( float4 ( vPosition , 1 ) , g_mSpotShadowViewProj [ nShadowIndex ] ) ; 
    shadowTexCoord . xyz = shadowTexCoord . xyz / shadowTexCoord . w ; 
    
    shadowTexCoord . x = shadowTexCoord . x / 2 + 0.5 ; 
    shadowTexCoord . y = shadowTexCoord . y / - 2 + 0.5 ; 
    
    shadowTexCoord . x += nShadowIndex ; 
    shadowTexCoord . x *= rcp ( 12 ) ; 
    
    shadowTexCoord . z -= g_ShadowBias . w ; 
    
    return FilterShadow ( g_SpotShadowAtlas , shadowTexCoord . xyz ) ; 
} 

void DoLighting ( uniform bool bDoShadow , in Buffer < float4 > PointLightBufferCenterAndRadius , in Buffer < float4 > PointLightBufferColor , in uint nLightIndex , in float3 vPosition , in float3 vNorm , in float3 vViewDir , out float3 LightColorDiffuseResult , out float3 LightColorSpecularResult ) 
{ 
    float4 CenterAndRadius = PointLightBufferCenterAndRadius [ nLightIndex ] ; 
    
    float3 vToLight = CenterAndRadius . xyz - vPosition ; 
    float3 vLightDir = normalize ( vToLight ) ; 
    float fLightDistance = length ( vToLight ) ; 
    
    LightColorDiffuseResult = float3 ( 0 , 0 , 0 ) ; 
    LightColorSpecularResult = float3 ( 0 , 0 , 0 ) ; 
    
    float fRad = CenterAndRadius . w ; 
    if ( fLightDistance < fRad ) 
    { 
        float x = fLightDistance / fRad ; 
        
#line 188
        float fFalloff = - 0.05 + 1.05 / ( 1 + 20 * x * x ) ; 
        LightColorDiffuseResult = PointLightBufferColor [ nLightIndex ] . rgb * saturate ( dot ( vLightDir , vNorm ) ) * fFalloff ; 
        
        float3 vHalfAngle = normalize ( vViewDir + vLightDir ) ; 
        LightColorSpecularResult = PointLightBufferColor [ nLightIndex ] . rgb * pow ( saturate ( dot ( vHalfAngle , vNorm ) ) , 8 ) * fFalloff ; 
        
        if ( bDoShadow ) 
        { 
            float fShadowResult = DoShadow ( nLightIndex , vPosition , vLightDir , x ) ; 
            LightColorDiffuseResult *= fShadowResult ; 
            LightColorSpecularResult *= fShadowResult ; 
        } 
    } 
} 

void DoSpotLighting ( uniform bool bDoShadow , in Buffer < float4 > SpotLightBufferCenterAndRadius , in Buffer < float4 > SpotLightBufferColor , in Buffer < float4 > SpotLightBufferSpotParams , in uint nLightIndex , in float3 vPosition , in float3 vNorm , in float3 vViewDir , out float3 LightColorDiffuseResult , out float3 LightColorSpecularResult ) 
{ 
    float4 BoundingSphereCenterAndRadius = SpotLightBufferCenterAndRadius [ nLightIndex ] ; 
    float4 SpotParams = SpotLightBufferSpotParams [ nLightIndex ] ; 
    
#line 209
    float3 SpotLightDir ; 
    SpotLightDir . xy = SpotParams . xy ; 
    SpotLightDir . z = sqrt ( 1 - SpotLightDir . x * SpotLightDir . x - SpotLightDir . y * SpotLightDir . y ) ; 
    
#line 214
    SpotLightDir . z = ( SpotParams . z > 0 ) ? SpotLightDir . z : - SpotLightDir . z ; 
    
#line 218
    float3 LightPosition = BoundingSphereCenterAndRadius . xyz - BoundingSphereCenterAndRadius . w * SpotLightDir ; 
    
    float3 vToLight = LightPosition - vPosition ; 
    float3 vToLightNormalized = normalize ( vToLight ) ; 
    float fLightDistance = length ( vToLight ) ; 
    float fCosineOfCurrentConeAngle = dot ( - vToLightNormalized , SpotLightDir ) ; 
    
    LightColorDiffuseResult = float3 ( 0 , 0 , 0 ) ; 
    LightColorSpecularResult = float3 ( 0 , 0 , 0 ) ; 
    
    float fRad = SpotParams . w ; 
    float fCosineOfConeAngle = ( SpotParams . z > 0 ) ? SpotParams . z : - SpotParams . z ; 
    if ( fLightDistance < fRad && fCosineOfCurrentConeAngle > fCosineOfConeAngle ) 
    { 
        float fRadialAttenuation = ( fCosineOfCurrentConeAngle - fCosineOfConeAngle ) / ( 1.0 - fCosineOfConeAngle ) ; 
        fRadialAttenuation = fRadialAttenuation * fRadialAttenuation ; 
        
        float x = fLightDistance / fRad ; 
        
#line 239
        float fFalloff = - 0.05 + 1.05 / ( 1 + 20 * x * x ) ; 
        LightColorDiffuseResult = SpotLightBufferColor [ nLightIndex ] . rgb * saturate ( dot ( vToLightNormalized , vNorm ) ) * fFalloff * fRadialAttenuation ; 
        
        float3 vHalfAngle = normalize ( vViewDir + vToLightNormalized ) ; 
        LightColorSpecularResult = SpotLightBufferColor [ nLightIndex ] . rgb * pow ( saturate ( dot ( vHalfAngle , vNorm ) ) , 8 ) * fFalloff * fRadialAttenuation ; 
        
        if ( bDoShadow ) 
        { 
            float fShadowResult = DoSpotShadow ( nLightIndex , vPosition ) ; 
            LightColorDiffuseResult *= fShadowResult ; 
            LightColorSpecularResult *= fShadowResult ; 
        } 
    } 
} 

void DoVPLLighting ( in StructuredBuffer < float4 > VPLBufferCenterAndRadius , in StructuredBuffer < VPLData > VPLBufferData , in uint nLightIndex , in float3 vPosition , in float3 vNorm , out float3 LightColorDiffuseResult ) 
{ 
    float4 CenterAndRadius = VPLBufferCenterAndRadius [ nLightIndex ] ; 
    VPLData Data = VPLBufferData [ nLightIndex ] ; 
    
    float3 vToLight = CenterAndRadius . xyz - vPosition ; 
    float3 vLightDir = normalize ( vToLight ) ; 
    float fLightDistance = length ( vToLight ) ; 
    
    LightColorDiffuseResult = float3 ( 0 , 0 , 0 ) ; 
    
    float fRad = CenterAndRadius . w ; 
    float fVPLNormalDotDir = max ( 0 , dot ( Data . Direction . xyz , - vLightDir ) ) ; 
    
    if ( fLightDistance < fRad && fVPLNormalDotDir > 0 ) 
    { 
        float3 LightColor = Data . Color . rgb ; 
        
        float x = fLightDistance / fRad ; 
        float fFalloff = smoothstep ( 1.0 , 0.0 , x ) ; 
        
        float fSourceLightNdotL = dot ( Data . SourceLightDirection . xyz , vNorm ) ; 
        if ( fSourceLightNdotL < 0.0 ) 
        { 
            fSourceLightNdotL = 1.0 + ( fSourceLightNdotL / g_fVPLRemoveBackFaceContrib ) ; 
        } 
        else 
        { 
            fSourceLightNdotL = 1.0 ; 
        } 
        
        LightColorDiffuseResult = LightColor * saturate ( dot ( vLightDir , vNorm ) ) * fFalloff * fVPLNormalDotDir * fSourceLightNdotL ; 
    } 
} 


#line 60 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\TilingDeferred.hlsl"
Buffer < float4 > g_PointLightBufferColor : register ( t4 ) ; 
Buffer < float4 > g_SpotLightBufferColor : register ( t5 ) ; 
Buffer < float4 > g_SpotLightBufferSpotParams : register ( t6 ) ; 

#line 66


#line 81

Texture2DMS < float4 , 2 > g_GBuffer0Texture : register ( t8 ) ; 
Texture2DMS < float4 , 2 > g_GBuffer1Texture : register ( t9 ) ; 

#line 86


#line 89


#line 92




RWTexture2D < float4 > g_OffScreenBufferOut : register ( u0 ) ; 

#line 102

float3 DoLightingForMSAA ( uint2 globalIdx , uint sampleIdx , float fHalfZ ) 
{ 
    
    float4 vNormAndSpecMask = g_GBuffer1Texture . Load ( globalIdx , sampleIdx ) ; 
    float3 vNorm = vNormAndSpecMask . xyz ; 
    vNorm *= 2 ; 
    vNorm -= float3 ( 1 , 1 , 1 ) ; 
    
#line 112
    float fDepthBufferDepth = g_DepthTexture . Load ( globalIdx , sampleIdx ) . x ; 
    float4 vWorldSpacePosition = mul ( float4 ( ( float ) globalIdx . x + 0.5 , ( float ) globalIdx . y + 0.5 , fDepthBufferDepth , 1.0 ) , g_mViewProjectionInvViewport ) ; 
    float3 vPositionWS = vWorldSpacePosition . xyz / vWorldSpacePosition . w ; 
    
    float3 vViewDir = normalize ( g_vCameraPos - vPositionWS ) ; 
    
    float3 AccumDiffuse = float3 ( 0 , 0 , 0 ) ; 
    float3 AccumSpecular = float3 ( 0 , 0 , 0 ) ; 
    
    float fViewPosZ = ConvertProjDepthToView ( fDepthBufferDepth ) ; 
    
#line 124
    { 
        uint uStartIdx = ( fViewPosZ < fHalfZ ) ? 0 : 272 ; 
        uint uEndIdx = ( fViewPosZ < fHalfZ ) ? ldsLightIdxCounterA : ldsLightIdxCounterB ; 
        
        for ( uint i = uStartIdx ; i < uEndIdx ; i ++ ) 
        { 
            uint nLightIndex = ldsLightIdx [ i ] ; 
            
            float3 LightColorDiffuseResult ; 
            float3 LightColorSpecularResult ; 
            
#line 136
            
            DoLighting ( false , g_PointLightBufferCenterAndRadius , g_PointLightBufferColor , nLightIndex , vPositionWS , vNorm , vViewDir , LightColorDiffuseResult , LightColorSpecularResult ) ; 
            
            
            AccumDiffuse += LightColorDiffuseResult ; 
            AccumSpecular += LightColorSpecularResult ; 
        } 
    } 
    
#line 146
    { 
        uint uStartIdx = ( fViewPosZ < fHalfZ ) ? 0 : 272 ; 
        uint uEndIdx = ( fViewPosZ < fHalfZ ) ? ldsSpotIdxCounterA : ldsSpotIdxCounterB ; 
        
        for ( uint i = uStartIdx ; i < uEndIdx ; i ++ ) 
        { 
            uint nLightIndex = ldsSpotIdx [ i ] ; 
            
            float3 LightColorDiffuseResult ; 
            float3 LightColorSpecularResult ; 
            
#line 158
            
            DoSpotLighting ( false , g_SpotLightBufferCenterAndRadius , g_SpotLightBufferColor , g_SpotLightBufferSpotParams , nLightIndex , vPositionWS , vNorm , vViewDir , LightColorDiffuseResult , LightColorSpecularResult ) ; 
            
            
            AccumDiffuse += LightColorDiffuseResult ; 
            AccumSpecular += LightColorSpecularResult ; 
        } 
    } 
    
#line 183
    
    
#line 186
    AccumDiffuse *= 2 ; 
    AccumSpecular *= 8 ; 
    
#line 195
    
    
#line 200
    
    
#line 205
    
    
#line 208
    float fAmbientBlend = 0.5f * vNorm . y + 0.5 ; 
    float3 Ambient = g_AmbientColorUp . rgb * fAmbientBlend + g_AmbientColorDown . rgb * ( 1 - fAmbientBlend ) ; 
    float3 DiffuseAndAmbient = AccumDiffuse + Ambient ; 
    
#line 213
    float3 DiffuseTex = g_GBuffer0Texture . Load ( globalIdx , sampleIdx ) . rgb ; 
    float fSpecMask = vNormAndSpecMask . a ; 
    
    float3 Result = DiffuseTex * ( DiffuseAndAmbient + AccumSpecular * fSpecMask ) ; 
    
#line 237
    
    
    return Result ; 
} 


#line 246
[ numthreads ( 16 , 16 , 1 ) ] 
void CullLightsAndDoLightingCS ( uint3 globalIdx : SV_DispatchThreadID , uint3 localIdx : SV_GroupThreadID , uint3 groupIdx : SV_GroupID ) 
{ 
    uint localIdxFlattened = localIdx . x + localIdx . y * 16 ; 
    
#line 254
    float fHalfZ ; 
    
#line 257
    
    bool bIsEdge = DoLightCulling ( globalIdx , localIdxFlattened , groupIdx , fHalfZ ) ; 
    
    
#line 264
    
    float4 vNormAndSpecMask = g_GBuffer1Texture . Load ( uint2 ( globalIdx . x , globalIdx . y ) , 0 ) ; 
    
    float3 vNorm = vNormAndSpecMask . xyz ; 
    vNorm *= 2 ; 
    vNorm -= float3 ( 1 , 1 , 1 ) ; 
    
#line 274
    
    float fDepthBufferDepth = g_DepthTexture . Load ( uint2 ( globalIdx . x , globalIdx . y ) , 0 ) . x ; 
    
    float4 vWorldSpacePosition = mul ( float4 ( ( float ) globalIdx . x + 0.5 , ( float ) globalIdx . y + 0.5 , fDepthBufferDepth , 1.0 ) , g_mViewProjectionInvViewport ) ; 
    float3 vPositionWS = vWorldSpacePosition . xyz / vWorldSpacePosition . w ; 
    
    float3 vViewDir = normalize ( g_vCameraPos - vPositionWS ) ; 
    
    float3 AccumDiffuse = float3 ( 0 , 0 , 0 ) ; 
    float3 AccumSpecular = float3 ( 0 , 0 , 0 ) ; 
    
    float fViewPosZ = ConvertProjDepthToView ( fDepthBufferDepth ) ; 
    
#line 288
    { 
        uint uStartIdx = ( fViewPosZ < fHalfZ ) ? 0 : 272 ; 
        uint uEndIdx = ( fViewPosZ < fHalfZ ) ? ldsLightIdxCounterA : ldsLightIdxCounterB ; 
        
        for ( uint i = uStartIdx ; i < uEndIdx ; i ++ ) 
        { 
            uint nLightIndex = ldsLightIdx [ i ] ; 
            
            float3 LightColorDiffuseResult ; 
            float3 LightColorSpecularResult ; 
            
#line 300
            
            DoLighting ( false , g_PointLightBufferCenterAndRadius , g_PointLightBufferColor , nLightIndex , vPositionWS , vNorm , vViewDir , LightColorDiffuseResult , LightColorSpecularResult ) ; 
            
            
            AccumDiffuse += LightColorDiffuseResult ; 
            AccumSpecular += LightColorSpecularResult ; 
        } 
    } 
    
#line 310
    { 
        uint uStartIdx = ( fViewPosZ < fHalfZ ) ? 0 : 272 ; 
        uint uEndIdx = ( fViewPosZ < fHalfZ ) ? ldsSpotIdxCounterA : ldsSpotIdxCounterB ; 
        
        for ( uint i = uStartIdx ; i < uEndIdx ; i ++ ) 
        { 
            uint nLightIndex = ldsSpotIdx [ i ] ; 
            
            float3 LightColorDiffuseResult ; 
            float3 LightColorSpecularResult ; 
            
#line 322
            
            DoSpotLighting ( false , g_SpotLightBufferCenterAndRadius , g_SpotLightBufferColor , g_SpotLightBufferSpotParams , nLightIndex , vPositionWS , vNorm , vViewDir , LightColorDiffuseResult , LightColorSpecularResult ) ; 
            
            
            AccumDiffuse += LightColorDiffuseResult ; 
            AccumSpecular += LightColorSpecularResult ; 
        } 
    } 
    
#line 347
    
    
#line 350
    AccumDiffuse *= 2 ; 
    AccumSpecular *= 8 ; 
    
#line 372
    
    
#line 377
    
    
#line 382
    
    
#line 387
    
    
    
#line 391
    float fAmbientBlend = 0.5f * vNorm . y + 0.5 ; 
    float3 Ambient = g_AmbientColorUp . rgb * fAmbientBlend + g_AmbientColorDown . rgb * ( 1 - fAmbientBlend ) ; 
    float3 DiffuseAndAmbient = AccumDiffuse + Ambient ; 
    
#line 398
    
    float3 DiffuseTex = g_GBuffer0Texture . Load ( uint2 ( globalIdx . x , globalIdx . y ) , 0 ) . rgb ; 
    
    float fSpecMask = vNormAndSpecMask . a ; 
    
    float3 Result = DiffuseTex * ( DiffuseAndAmbient + AccumSpecular * fSpecMask ) ; 
    
#line 425
    
    
#line 429
    
    
    uint2 uavMsaaBufferCoord = globalIdx . xy * uint2 ( 2 , 2 ) ; 
    g_OffScreenBufferOut [ uavMsaaBufferCoord ] = float4 ( Result , 1 ) ; 
    
    for ( uint sampleIdx = 1 ; sampleIdx < 2 ; sampleIdx ++ ) 
    { 
        float3 vNormSample = g_GBuffer1Texture . Load ( uint2 ( globalIdx . x , globalIdx . y ) , sampleIdx ) . xyz ; 
        vNormSample *= 2 ; 
        vNormSample -= float3 ( 1 , 1 , 1 ) ; 
        bIsEdge = bIsEdge || dot ( vNormSample , vNorm ) < 0.984807753f ; 
    } 
    
    if ( bIsEdge ) 
    { 
        
#line 446
        uint dstIdx = 0 ; 
        InterlockedAdd ( ldsEdgePixelIdxCounter , 1 , dstIdx ) ; 
        ldsEdgePixelIdx [ dstIdx ] = ( globalIdx . y << 16 ) | globalIdx . x ; 
    } 
    else 
    { 
        g_OffScreenBufferOut [ uavMsaaBufferCoord + uint2 ( 1 , 0 ) ] = float4 ( Result , 1 ) ; 
        g_OffScreenBufferOut [ uavMsaaBufferCoord + uint2 ( 0 , 1 ) ] = float4 ( Result , 1 ) ; 
        g_OffScreenBufferOut [ uavMsaaBufferCoord + uint2 ( 1 , 1 ) ] = float4 ( Result , 1 ) ; 
    } 
    
    GroupMemoryBarrierWithGroupSync ( ) ; 
    
#line 460
    { 
        uint uNumSamplesToLight = ( 2 - 1 ) * ldsEdgePixelIdxCounter ; 
        
        for ( uint i = localIdxFlattened ; i < uNumSamplesToLight ; i += ( 16 * 16 ) ) 
        { 
            uint edgePixelListIdx = i / ( 2 - 1 ) ; 
            uint sampleIdx = ( i % ( 2 - 1 ) ) + 1 ; 
            
            uint edgePixelIdxPacked = ldsEdgePixelIdx [ edgePixelListIdx ] ; 
            uint2 globalIdxForThisEdgePixel = uint2 ( edgePixelIdxPacked & 0x0000FFFF , edgePixelIdxPacked >> 16 ) ; 
            
            uint2 litSampleCoord = globalIdxForThisEdgePixel * uint2 ( 2 , 2 ) ; 
            litSampleCoord . x += sampleIdx % 2 ; 
            litSampleCoord . y += sampleIdx > 1 ; 
            g_OffScreenBufferOut [ litSampleCoord ] = float4 ( DoLightingForMSAA ( globalIdxForThisEdgePixel , sampleIdx , fHalfZ ) , 1 ) ; 
        } 
    } 
    
} 
 