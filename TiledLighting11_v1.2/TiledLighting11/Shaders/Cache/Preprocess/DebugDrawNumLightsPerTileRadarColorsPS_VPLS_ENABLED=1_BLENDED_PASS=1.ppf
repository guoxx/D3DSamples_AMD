#pragma warning (disable:3571)
#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\DebugDraw.hlsl"


#line 53


#line 1 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\CommonHeader.h"


#line 56
static const float4 kRadarColors [ 14 ] = 
{ 
    { 0 , 0.9255 , 0.9255 , 1 } , 
    { 0 , 0.62745 , 0.9647 , 1 } , 
    { 0 , 0 , 0.9647 , 1 } , 
    { 0 , 1 , 0 , 1 } , 
    { 0 , 0.7843 , 0 , 1 } , 
    { 0 , 0.5647 , 0 , 1 } , 
    { 1 , 1 , 0 , 1 } , 
    { 0.90588 , 0.75294 , 0 , 1 } , 
    { 1 , 0.5647 , 0 , 1 } , 
    { 1 , 0 , 0 , 1 } , 
    { 0.8392 , 0 , 0 , 1 } , 
    { 0.75294 , 0 , 0 , 1 } , 
    { 1 , 0 , 1 , 1 } , 
    { 0.6 , 0.3333 , 0.7882 , 1 } , 
} ; 

#line 78




#line 86



#line 92
cbuffer cbPerObject : register ( b0 ) 
{ 
    matrix g_mWorld : packoffset ( c0 ) ; 
} 

cbuffer cbPerCamera : register ( b1 ) 
{ 
    matrix g_mViewProjection : packoffset ( c0 ) ; 
} ; 

cbuffer cbPerFrame : register ( b2 ) 
{ 
    matrix g_mView : packoffset ( c0 ) ; 
    matrix g_mProjection : packoffset ( c4 ) ; 
    matrix g_mProjectionInv : packoffset ( c8 ) ; 
    matrix g_mViewProjectionInvViewport : packoffset ( c12 ) ; 
    float4 g_AmbientColorUp : packoffset ( c16 ) ; 
    float4 g_AmbientColorDown : packoffset ( c17 ) ; 
    float3 g_vCameraPos : packoffset ( c18 ) ; 
    float g_fAlphaTest : packoffset ( c18 . w ) ; 
    uint g_uNumLights : packoffset ( c19 ) ; 
    uint g_uNumSpotLights : packoffset ( c19 . y ) ; 
    uint g_uWindowWidth : packoffset ( c19 . z ) ; 
    uint g_uWindowHeight : packoffset ( c19 . w ) ; 
    uint g_uMaxNumLightsPerTile : packoffset ( c20 ) ; 
    uint g_uMaxNumElementsPerTile : packoffset ( c20 . y ) ; 
    uint g_uNumTilesX : packoffset ( c20 . z ) ; 
    uint g_uNumTilesY : packoffset ( c20 . w ) ; 
    uint g_uMaxVPLs : packoffset ( c21 ) ; 
    uint g_uMaxNumVPLsPerTile : packoffset ( c21 . y ) ; 
    uint g_uMaxNumVPLElementsPerTile : packoffset ( c21 . z ) ; 
    float g_fVPLSpotStrength : packoffset ( c21 . w ) ; 
    float g_fVPLSpotRadius : packoffset ( c22 ) ; 
    float g_fVPLPointStrength : packoffset ( c22 . y ) ; 
    float g_fVPLPointRadius : packoffset ( c22 . z ) ; 
    float g_fVPLRemoveBackFaceContrib : packoffset ( c22 . w ) ; 
    float g_fVPLColorThreshold : packoffset ( c23 ) ; 
    float g_fVPLBrightnessThreshold : packoffset ( c23 . y ) ; 
    float g_fPerFramePad1 : packoffset ( c23 . z ) ; 
    float g_fPerFramePad2 : packoffset ( c23 . w ) ; 
} ; 

cbuffer cbShadowConstants : register ( b3 ) 
{ 
    matrix g_mPointShadowViewProj [ 12 ] [ 6 ] ; 
    matrix g_mSpotShadowViewProj [ 12 ] ; 
    float4 g_ShadowBias ; 
} ; 

cbuffer cbVPLConstants : register ( b4 ) 
{ 
    uint g_uNumVPLs ; 
    uint g_uVPLPad [ 3 ] ; 
} ; 

struct VPLData 
{ 
    float4 Direction ; 
    float4 Color ; 
    float4 SourceLightDirection ; 
} ; 

#line 157
SamplerState g_Sampler : register ( s0 ) ; 
SamplerComparisonState g_ShadowSampler : register ( s1 ) ; 

#line 166
float4 ConvertProjToView ( float4 p ) 
{ 
    p = mul ( p , g_mProjectionInv ) ; 
    p /= p . w ; 
    return p ; 
} 

#line 174
float ConvertProjDepthToView ( float z ) 
{ 
    z = 1.f / ( z * g_mProjectionInv . _34 + g_mProjectionInv . _44 ) ; 
    return z ; 
} 

uint GetTileIndex ( float2 ScreenPos ) 
{ 
    float fTileRes = ( float ) 16 ; 
    uint nTileIdx = floor ( ScreenPos . x / fTileRes ) + floor ( ScreenPos . y / fTileRes ) * g_uNumTilesX ; 
    return nTileIdx ; 
} 

#line 189
void GetLightListInfo ( in Buffer < uint > PerTileLightIndexBuffer , in uint uMaxNumLightsPerTile , in uint uMaxNumElementsPerTile , in float4 SVPosition , out uint uFirstLightIndex , out uint uNumLights ) 
{ 
    uint nTileIndex = GetTileIndex ( SVPosition . xy ) ; 
    uint nStartIndex = uMaxNumElementsPerTile * nTileIndex ; 
    
#line 195
    uint uHalfZBitsHigh = PerTileLightIndexBuffer [ nStartIndex ] ; 
    uint uHalfZBitsLow = PerTileLightIndexBuffer [ nStartIndex + 1 ] ; 
    uint uHalfZBits = ( uHalfZBitsHigh << 16 ) | uHalfZBitsLow ; 
    float fHalfZ = asfloat ( uHalfZBits ) ; 
    
    float fViewPosZ = ConvertProjDepthToView ( SVPosition . z ) ; 
    
    uFirstLightIndex = ( fViewPosZ < fHalfZ ) ? ( nStartIndex + 4 ) : ( nStartIndex + 4 + uMaxNumLightsPerTile ) ; 
    uNumLights = ( fViewPosZ < fHalfZ ) ? PerTileLightIndexBuffer [ nStartIndex + 2 ] : PerTileLightIndexBuffer [ nStartIndex + 3 ] ; 
} 

float4 ConvertNumberOfLightsToGrayscale ( uint nNumLightsInThisTile , uint uMaxNumLightsPerTile ) 
{ 
    float fPercentOfMax = ( float ) nNumLightsInThisTile / ( float ) uMaxNumLightsPerTile ; 
    return float4 ( fPercentOfMax , fPercentOfMax , fPercentOfMax , 1.0f ) ; 
} 

float4 ConvertNumberOfLightsToRadarColor ( uint nNumLightsInThisTile , uint uMaxNumLightsPerTile ) 
{ 
    
    if ( nNumLightsInThisTile == 0 ) return float4 ( 0 , 0 , 0 , 1 ) ; 
    
    else if ( nNumLightsInThisTile == uMaxNumLightsPerTile ) return float4 ( 0.847 , 0.745 , 0.921 , 1 ) ; 
    
    else if ( nNumLightsInThisTile > uMaxNumLightsPerTile ) return float4 ( 1 , 1 , 1 , 1 ) ; 
    
    else 
    { 
        
#line 227
        float fLogBase = exp2 ( 0.07142857f * log2 ( ( float ) uMaxNumLightsPerTile ) ) ; 
        
#line 231
        uint nColorIndex = floor ( log2 ( ( float ) nNumLightsInThisTile ) / log2 ( fLogBase ) ) ; 
        return kRadarColors [ nColorIndex ] ; 
    } 
} 


#line 56 "\\\\?\\D:\\Downloads\\TiledLighting11_v1.2\\TiledLighting11\\Shaders\\source\\DebugDraw.hlsl"


#line 65
Buffer < float4 > g_PointLightBufferCenterAndRadius : register ( t2 ) ; 
Buffer < float4 > g_PointLightBufferColor : register ( t3 ) ; 
Buffer < uint > g_PerTileLightIndexBuffer : register ( t4 ) ; 

Buffer < float4 > g_SpotLightBufferCenterAndRadius : register ( t5 ) ; 
Buffer < float4 > g_SpotLightBufferColor : register ( t6 ) ; 
Buffer < float4 > g_SpotLightBufferSpotParams : register ( t7 ) ; 
Buffer < uint > g_PerTileSpotIndexBuffer : register ( t8 ) ; 


StructuredBuffer < float4 > g_VPLBufferCenterAndRadius : register ( t9 ) ; 
StructuredBuffer < VPLData > g_VPLBufferData : register ( t10 ) ; 
Buffer < uint > g_PerTileVPLIndexBuffer : register ( t11 ) ; 


Buffer < float4 > g_SpotLightBufferSpotMatrices : register ( t12 ) ; 

#line 85
uint GetNumLightsInThisTile ( Buffer < uint > PerTileLightIndexBuffer , uint uMaxNumLightsPerTile , uint uMaxNumElementsPerTile , float4 SVPosition ) 
{ 
    uint nIndex , nNumLightsInThisTile ; 
    GetLightListInfo ( PerTileLightIndexBuffer , uMaxNumLightsPerTile , uMaxNumElementsPerTile , SVPosition , nIndex , nNumLightsInThisTile ) ; 
    return nNumLightsInThisTile ; 
} 

#line 95
struct VS_INPUT_POS_TEX 
{ 
    float3 Position : POSITION ; 
    float2 TextureUV : TEXCOORD0 ; 
} ; 

struct VS_OUTPUT_POS_TEX 
{ 
    float4 Position : SV_POSITION ; 
    float2 TextureUV : TEXCOORD0 ; 
} ; 

struct VS_INPUT_DRAW_POINT_LIGHTS 
{ 
    float3 Position : POSITION ; 
    float2 TextureUV : TEXCOORD0 ; 
    uint InstanceID : SV_InstanceID ; 
} ; 

struct VS_OUTPUT_DRAW_POINT_LIGHTS 
{ 
    float4 Position : SV_POSITION ; 
    float3 Color : COLOR0 ; 
    float2 TextureUV : TEXCOORD0 ; 
} ; 

struct VS_INPUT_DRAW_SPOT_LIGHTS 
{ 
    float3 Position : POSITION ; 
    float3 Normal : NORMAL ; 
    float2 TextureUV : TEXCOORD0 ; 
    uint InstanceID : SV_InstanceID ; 
} ; 

struct VS_OUTPUT_DRAW_SPOT_LIGHTS 
{ 
    float4 Position : SV_POSITION ; 
    float3 Normal : NORMAL ; 
    float4 Color : COLOR0 ; 
    float2 TextureUV : TEXCOORD0 ; 
    float3 PositionWS : TEXCOORD1 ; 
} ; 

struct VS_OUTPUT_POSITION_ONLY 
{ 
    float4 Position : SV_POSITION ; 
} ; 

#line 147
VS_OUTPUT_DRAW_POINT_LIGHTS DebugDrawPointLightsVS ( VS_INPUT_DRAW_POINT_LIGHTS Input ) 
{ 
    VS_OUTPUT_DRAW_POINT_LIGHTS Output ; 
    
#line 152
    float4 LightPositionViewSpace = mul ( float4 ( g_PointLightBufferCenterAndRadius [ Input . InstanceID ] . xyz , 1 ) , g_mView ) ; 
    
#line 155
    LightPositionViewSpace . xy = LightPositionViewSpace . xy + Input . Position . xy ; 
    
#line 158
    Output . Position = mul ( LightPositionViewSpace , g_mProjection ) ; 
    
#line 161
    Output . Color = g_PointLightBufferColor [ Input . InstanceID ] . rgb ; 
    Output . TextureUV = Input . TextureUV ; 
    return Output ; 
} 

#line 170
VS_OUTPUT_DRAW_SPOT_LIGHTS DebugDrawSpotLightsVS ( VS_INPUT_DRAW_SPOT_LIGHTS Input ) 
{ 
    VS_OUTPUT_DRAW_SPOT_LIGHTS Output ; 
    
    float4 BoundingSphereCenterAndRadius = g_SpotLightBufferCenterAndRadius [ Input . InstanceID ] ; 
    float4 SpotParams = g_SpotLightBufferSpotParams [ Input . InstanceID ] ; 
    
#line 178
    float3 SpotLightDir ; 
    SpotLightDir . xy = SpotParams . xy ; 
    SpotLightDir . z = sqrt ( 1 - SpotLightDir . x * SpotLightDir . x - SpotLightDir . y * SpotLightDir . y ) ; 
    
#line 183
    SpotLightDir . z = ( SpotParams . z > 0 ) ? SpotLightDir . z : - SpotLightDir . z ; 
    
#line 187
    float3 LightPosition = BoundingSphereCenterAndRadius . xyz - BoundingSphereCenterAndRadius . w * SpotLightDir ; 
    
#line 190
    float4x4 LightRotation = { g_SpotLightBufferSpotMatrices [ 4 * Input . InstanceID ] , 
        g_SpotLightBufferSpotMatrices [ 4 * Input . InstanceID + 1 ] , 
        g_SpotLightBufferSpotMatrices [ 4 * Input . InstanceID + 2 ] , 
        g_SpotLightBufferSpotMatrices [ 4 * Input . InstanceID + 3 ] } ; 
    float3 VertexPosition = mul ( Input . Position , ( float3x3 ) LightRotation ) + LightPosition ; 
    float3 VertexNormal = mul ( Input . Normal , ( float3x3 ) LightRotation ) ; 
    
#line 198
    Output . Position = mul ( float4 ( VertexPosition , 1 ) , g_mViewProjection ) ; 
    
#line 201
    Output . PositionWS = VertexPosition ; 
    Output . Normal = VertexNormal ; 
    
#line 205
    Output . Color = g_SpotLightBufferColor [ Input . InstanceID ] ; 
    Output . TextureUV = Input . TextureUV ; 
    return Output ; 
} 

#line 213
float4 DebugDrawPointLightsPS ( VS_OUTPUT_DRAW_POINT_LIGHTS Input ) : SV_TARGET 
{ 
    float fRad = 0.5f ; 
    float2 Crd = Input . TextureUV - float2 ( fRad , fRad ) ; 
    float fCrdLength = length ( Crd ) ; 
    
#line 220
    if ( fCrdLength > fRad ) discard ; 
    
#line 223
    float x = ( 1.f - fCrdLength / fRad ) ; 
    return float4 ( 0.5f * pow ( x , 5.f ) * Input . Color + 2.f * pow ( x , 20.f ) , 1 ) ; 
} 

#line 230
float4 DebugDrawSpotLightsPS ( VS_OUTPUT_DRAW_SPOT_LIGHTS Input ) : SV_TARGET 
{ 
    float3 vViewDir = normalize ( g_vCameraPos - Input . PositionWS ) ; 
    float3 vNormal = normalize ( Input . Normal ) ; 
    float fViewDirDotSurfaceNormal = dot ( vViewDir , vNormal ) ; 
    
    float3 color = Input . Color . rgb ; 
    color *= fViewDirDotSurfaceNormal < 0.0 ? 0.5 : 1.0 ; 
    
    return float4 ( color , 1 ) ; 
} 

#line 245
float4 DebugDrawNumLightsPerTileGrayscalePS ( VS_OUTPUT_POSITION_ONLY Input ) : SV_TARGET 
{ 
    uint nNumLightsInThisTile = GetNumLightsInThisTile ( g_PerTileLightIndexBuffer , g_uMaxNumLightsPerTile , g_uMaxNumElementsPerTile , Input . Position ) ; 
    nNumLightsInThisTile += GetNumLightsInThisTile ( g_PerTileSpotIndexBuffer , g_uMaxNumLightsPerTile , g_uMaxNumElementsPerTile , Input . Position ) ; 
    uint uMaxNumLightsPerTile = 2 * g_uMaxNumLightsPerTile ; 
    
    
#line 253
    
    uMaxNumLightsPerTile += g_uMaxNumVPLsPerTile ; 
    
    return ConvertNumberOfLightsToGrayscale ( nNumLightsInThisTile , uMaxNumLightsPerTile ) ; 
} 

#line 262
float4 DebugDrawNumLightsPerTileRadarColorsPS ( VS_OUTPUT_POSITION_ONLY Input ) : SV_TARGET 
{ 
    uint nNumLightsInThisTile = GetNumLightsInThisTile ( g_PerTileLightIndexBuffer , g_uMaxNumLightsPerTile , g_uMaxNumElementsPerTile , Input . Position ) ; 
    nNumLightsInThisTile += GetNumLightsInThisTile ( g_PerTileSpotIndexBuffer , g_uMaxNumLightsPerTile , g_uMaxNumElementsPerTile , Input . Position ) ; 
    uint uMaxNumLightsPerTile = 2 * g_uMaxNumLightsPerTile ; 
    
    
#line 270
    
    uMaxNumLightsPerTile += g_uMaxNumVPLsPerTile ; 
    
    return ConvertNumberOfLightsToRadarColor ( nNumLightsInThisTile , uMaxNumLightsPerTile ) ; 
} 

#line 280
VS_OUTPUT_POS_TEX DebugDrawLegendForNumLightsPerTileVS ( VS_INPUT_POS_TEX Input ) 
{ 
    VS_OUTPUT_POS_TEX Output ; 
    
#line 285
    Output . Position . x = 2.0f * ( Input . Position . x / ( float ) g_uWindowWidth ) - 1.0f ; 
    Output . Position . y = - 2.0f * ( Input . Position . y / ( float ) g_uWindowHeight ) + 1.0f ; 
    Output . Position . z = 0.0f ; 
    Output . Position . w = 1.0f ; 
    
#line 291
    Output . TextureUV = Input . TextureUV ; 
    
    return Output ; 
} 

#line 300
float4 DebugDrawLegendForNumLightsPerTileGrayscalePS ( VS_OUTPUT_POS_TEX Input ) : SV_TARGET 
{ 
    float fGradVal = Input . TextureUV . y ; 
    return float4 ( fGradVal , fGradVal , fGradVal , 1.0f ) ; 
} 

#line 310
float4 DebugDrawLegendForNumLightsPerTileRadarColorsPS ( VS_OUTPUT_POS_TEX Input ) : SV_TARGET 
{ 
    uint nBandIdx = floor ( 16.999f * Input . TextureUV . y ) ; 
    
#line 315
    if ( nBandIdx == 0 ) return float4 ( 0 , 0 , 0 , 1 ) ; 
    
    else if ( nBandIdx == 15 ) return float4 ( 0.847 , 0.745 , 0.921 , 1 ) ; 
    
    else if ( nBandIdx == 16 ) return float4 ( 1 , 1 , 1 , 1 ) ; 
    
    else 
    { 
        
        uint nColorIndex = nBandIdx - 1 ; 
        return kRadarColors [ nColorIndex ] ; 
    } 
} 
 